#include "utils/spill.jazz"
#include "utils/math.jazz"
#include "utils/memory.jazz"

// hkpadded with (32 + 128)
inline fn __hkdfsha256_extract(reg u64 PRK IKM IKMlen salt saltlen hkpadded)
{
  _hmacsha256(PRK, IKM, IKMlen, salt, saltlen, hkpadded);
}

// hkpadded_Tinfoc: hkpadded (32 + 128) + Tinfoc (32 + infolen + 1)
#[returnaddress="stack"]
fn _hkdfsha256_expand(reg u64 OKM PRK info infolen L hkpadded_Tinfoc)
{
  stack u64 N_s L_s OKM_s Tinfoc_s infoc_s Tinfoclen_s infolen_s PRK_s hkpadded_s;
  stack u8 C_s;

  reg u64 N _L _PRK Tlen Tinfoc infoc Tinfoclen hkpadded len;
  reg u8 C;

  hkpadded = hkpadded_Tinfoc;
  Tinfoc = hkpadded_Tinfoc + (32+128);

  // N = ceil(L/HashLen)
  _L = L;
  N = __ceil_pow2(_L, 5, 0x1F);

  // OKM = first L octets of T
  //  where T = T(1) | T(2) | T(3) | ... | T(N)
  //        T0 = empty string (zero length)
  //        T1 = HMAC-Hash(PRK, T0 | info | 0x01)
  //        T2 = HMAC-Hash(PRK, T1 | info | 0x02)

  __memcpy_u8_do(Tinfoc, 32, info, infolen);

  Tlen = 0;
  C = 0x1;

  while(N > 0)
  {
    (u8)[Tinfoc + 32 + infolen] = C;

    // this code should compile with -lea and -no-lea because of different
    // implementations of sha256, so we use the lea directly
    Tinfoclen = #LEA_64(infolen + 1);
    Tinfoclen += Tlen;

    infoc = #LEA_64(Tinfoc + 32);
    infoc -= Tlen;

    N_s, L_s, OKM_s, Tinfoc_s, infoc_s, Tinfoclen_s, infolen_s, PRK_s, hkpadded_s = 
      __r2s_x9(N, L, OKM, Tinfoc, infoc, Tinfoclen, infolen, PRK, hkpadded);
    C_s = C;

    len = 32;
    _PRK = PRK;
    _hmacsha256(Tinfoc, infoc, Tinfoclen, _PRK, len, hkpadded);

    C = C_s;
    N, L, OKM, Tinfoc, infoc, Tinfoclen, infolen, PRK, hkpadded = 
      __s2r_x9(N_s, L_s, OKM_s, Tinfoc_s, infoc_s, Tinfoclen_s, infolen_s, PRK_s, hkpadded_s);

    len = 32;
    Tlen = __min(len, L);
    __memcpy_u8(OKM, Tinfoc, Tlen);

    OKM += Tlen;
    L -= Tlen;

    N -= 1;
    C += 1;
  }
}

