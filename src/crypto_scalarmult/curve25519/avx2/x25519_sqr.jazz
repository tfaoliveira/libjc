#ifndef X25519_SQR
#define X25519_SQR

#include "x25519_globals.jazz"
#include "x25519_macros.jazz"

inline fn __sqr_rs(stack u256[5] a) -> reg u256[5]
{
  inline int i;
  reg u256 x ai aj a2i a2j;
  reg u256[5] br dr er c k t;
  stack u256[5] d e;

  br = a;

  for i=4 downto -1
  { er[i] = MUL(br[i], g_times_19);
    //dr[i] = ALIGNX(br[i],er[i]);
    ALIGNR(dr[i],br[i],er[i]);
    e[i]  = er[i]; 
    d[i]  = dr[i]; }

  //
  ai   = SHUF32(a[0],0x44);     aj   = SHUF32(a[1],0x44); // FIX C
  a2i  = ai +4u64 ai;           a2j  = aj +4u64 aj;
  c[0] = MUL(ai, a[0]);         k[0] = MUL(a2j,d[4]);
  c[1] = MUL(a2i,a[1]);
  c[2] = MUL(a2i,a[2]);         k[2] = MUL(aj, a[1]);
  c[3] = MUL(a2i,a[3]);         k[3] = MUL(a2j,a[2]);
  c[4] = MUL(a2i,a[4]);         k[4] = MUL(a2j,a[3]);

  //
  ai   = SHUF32(a[2], 0x44);    aj   = SHUF32(a[3], 0x44);
  a2i  = ai +4u64 ai;           a2j  = aj +4u64 aj;
  ADD_MUL(c[0],a2i,d[3]);
  ADD_MUL(c[1],a2i,d[4]);       k[1] = MUL(aj, d[3]);
                                ADD_MUL(k[2],a2j,d[4]);

  ADD_MUL(c[4],ai,a[2]);

  //
  ai   = SHUF32(a[4],0x44);     aj   = SHUF32(a[0],0xEE);
  a2i  = ai +4u64 ai;           a2j  = aj +4u64 aj;
                                ADD_MUL(k[0],aj, d[0]);
                                ADD_MUL(k[1],a2j,d[1]);
                                ADD_MUL(k[2],a2j,d[2]);
  ADD_MUL(c[3],ai,d[4]);        ADD_MUL(k[3],a2j,d[3]);
                                ADD_MUL(k[4],a2j,d[4]);

  //
  ai   = SHUF32(a[1],0xEE);     aj  = SHUF32(a[2],0xEE);
  a2i  = ai +4u64 ai;           a2j = aj +4u64 aj;
  ADD_MUL(c[0],a2i,e[4]);       ADD_MUL(k[0],a2j,e[3]);
                                ADD_MUL(k[1],a2j,e[4]);
  ADD_MUL(c[2],ai, d[1]);
  ADD_MUL(c[3],a2i,d[2]);
  ADD_MUL(c[4],a2i,d[3]);       ADD_MUL(k[4],aj,d[2]);

  //
  ai  = SHUF32(a[3],0xEE);      aj = SHUF32(a[4],0xEE);
  a2i = ai +4u64 ai;

  ADD_MUL(c[1],ai,e[3]);
  ADD_MUL(c[2],a2i,e[4]);
                                ADD_MUL(k[3],aj,e[4]);

  //
  t[0] = SHLV(k[0],g_sh_0);
  t[1] = SHLV(k[1],g_sh_1);
  t[2] = SHLV(k[2],g_sh_0);
  t[3] = SHLV(k[3],g_sh_1);
  t[4] = SHLV(k[4],g_sh_0);

  c[0] +4u64= t[0];
  c[1] +4u64= t[1];
  c[2] +4u64= t[2];
  c[3] +4u64= t[3];
  c[4] +4u64= t[4];

  return c;
}

inline fn __sqr_rm(reg u64 a) -> reg u256[5]
{
  inline int i;
  reg u256 x ai aj a2i a2j;
  reg u256[5] br dr er c k t;
  stack u256[5] d e;

  for i=0 to 5
  { br[i] = (u256)[a + 32*i]; }

  for i=4 downto -1
  { er[i] = MUL(br[i], g_times_19);
    //dr[i] = ALIGNX(br[i],er[i]);
    ALIGNR(dr[i],br[i],er[i]);
    e[i]  = er[i]; 
    d[i]  = dr[i]; }

  //
  ai   = SHUF32_M(a,0,0x44);    aj   = SHUF32_M(a,1,0x44);
  a2i  = ai +4u64 ai;           a2j  = aj +4u64 aj;
  c[0] = MUL_M(ai, a,0);        k[0] = MUL(a2j,d[4]);
  c[1] = MUL_M(a2i,a,1);
  c[2] = MUL_M(a2i,a,2);        k[2] = MUL_M(aj, a,1);
  c[3] = MUL_M(a2i,a,3);        k[3] = MUL_M(a2j,a,2);
  c[4] = MUL_M(a2i,a,4);        k[4] = MUL_M(a2j,a,3);

  //
  ai   = SHUF32_M(a,2,0x44);    aj   = SHUF32_M(a,3,0x44);
  a2i  = ai +4u64 ai;           a2j  = aj +4u64 aj;
  ADD_MUL(c[0],a2i,d[3]);
  ADD_MUL(c[1],a2i,d[4]);       k[1] = MUL(aj, d[3]);
                                ADD_MUL(k[2],a2j,d[4]);

  ADD_MUL_M(c[4],ai,a,2);

  //
  ai   = SHUF32_M(a,4,0x44);    aj   = SHUF32_M(a,0,0xEE);
  a2i  = ai +4u64 ai;           a2j  = aj +4u64 aj;
                                ADD_MUL(k[0],aj, d[0]);
                                ADD_MUL(k[1],a2j,d[1]);
                                ADD_MUL(k[2],a2j,d[2]);
  ADD_MUL(c[3],ai,d[4]);        ADD_MUL(k[3],a2j,d[3]);
                                ADD_MUL(k[4],a2j,d[4]);

  //
  ai   = SHUF32_M(a,1,0xEE);    aj  = SHUF32_M(a,2,0xEE);
  a2i  = ai +4u64 ai;           a2j = aj +4u64 aj;
  ADD_MUL(c[0],a2i,e[4]);       ADD_MUL(k[0],a2j,e[3]);
                                ADD_MUL(k[1],a2j,e[4]);
  ADD_MUL(c[2],ai, d[1]);
  ADD_MUL(c[3],a2i,d[2]);
  ADD_MUL(c[4],a2i,d[3]);       ADD_MUL(k[4],aj,d[2]);

  //
  ai  = SHUF32_M(a,3,0xEE);      aj = SHUF32_M(a,4,0xEE);
  a2i = ai +4u64 ai;

  ADD_MUL(c[1],ai,e[3]);
  ADD_MUL(c[2],a2i,e[4]);
                                ADD_MUL(k[3],aj,e[4]);

  //
  t[0] = SHLV(k[0],g_sh_0);
  t[1] = SHLV(k[1],g_sh_1);
  t[2] = SHLV(k[2],g_sh_0);
  t[3] = SHLV(k[3],g_sh_1);
  t[4] = SHLV(k[4],g_sh_0);

  c[0] +4u64= t[0];
  c[1] +4u64= t[1];
  c[2] +4u64= t[2];
  c[3] +4u64= t[3];
  c[4] +4u64= t[4];

  return c;
}

#ifdef EXPORT

export fn sqr_rs(reg u64 cp ap)
{
  inline int i;
  reg u256 av;
  reg u256[5] c;
  stack u256[5] a;

  for i=0 to 5
  { av = (u256)[ap + 32*i];
    a[i] = av;
  }
  c = __sqr_rs(a);

  for i=0 to 5
  { (u256)[cp + 32*i] = c[i]; }
}

export fn sqr_rm(reg u64 cp ap)
{
  inline int i;
  reg u256[5] cr;
  cr = __sqr_rm(ap);
  for i=0 to 5
  { (u256)[cp + 32*i] = cr[i]; }
}

#endif

#endif
