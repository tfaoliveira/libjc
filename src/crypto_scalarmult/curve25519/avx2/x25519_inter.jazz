#ifndef X25519_AVX2_INTER
#define X25519_AVX2_INTER

#include "crypto_scalarmult/curve25519/avx2/x25519_globals.jazz"
#include "crypto_scalarmult/curve25519/avx2/x25519_macros.jazz"

inline fn __rrx_inter1_rr(reg u256[3] a0) -> reg u256[5]
{
  reg u256 A0 A4 A8 B0 B4 B8;
  reg u256[5] r;

  A0 = a0[0];
  A4 = a0[1];
  A8 = a0[2];
  B0 = A0;
  B4 = A4;
  B8 = A8;

  r[0] = #VPERM2I128(A0, B0, (2u4)[2,0]);
  r[1] = #VPERM2I128(A0, B0, (2u4)[3,1]);
  r[2] = #VPERM2I128(A4, B4, (2u4)[2,0]);
  r[3] = #VPERM2I128(A4, B4, (2u4)[3,1]);
  r[4] = #VPERM2I128(A8, B8, (2u4)[2,0]);

  return r;
}

inline fn __rrx_inter2_rss(stack u256[3] a0 a1) -> reg u256[5]
{
  reg u256 A0 A4 A8 B0 B4 B8;
  reg u256[5] r;

  A0 = a0[0];
  A4 = a0[1];
  A8 = a0[2];
  B0 = a1[0];
  B4 = a1[1];
  B8 = a1[2];

  r[0] = #VPERM2I128(A0, B0, (2u4)[2,0]);
  r[1] = #VPERM2I128(A0, B0, (2u4)[3,1]);
  r[2] = #VPERM2I128(A4, B4, (2u4)[2,0]);
  r[3] = #VPERM2I128(A4, B4, (2u4)[3,1]);
  r[4] = #VPERM2I128(A8, B8, (2u4)[2,0]);

  return r;
}

inline fn __rrx_deinter_rrr(reg u256[5] a) -> reg u256[3], reg u256[3]
{
  reg u256 t;
  reg u256[3] a0 a1;

  a0[0] = #VPERM2I128(a[0], a[1], (2u4)[2,0]);
  a1[0] = #VPERM2I128(a[0], a[1], (2u4)[3,1]);
  a0[1] = #VPERM2I128(a[2], a[3], (2u4)[2,0]);
  a1[1] = #VPERM2I128(a[2], a[3], (2u4)[3,1]);
  a0[2] = a[4];

  //TODO: CHECKME bottleneck: cast u128 into u256 with undefined high?
  t = #set0_256();
  a1[2] = #VPERM2I128(t, a[4], (2u4)[0,3]);
  return a0, a1;
}

inline fn __rrx_deinter1_sr(reg u256[5] a) -> stack u256[3]
{
  reg   u256 t;
  reg   u256[3] a0;
  stack u256[3] a0s;

  a0[0]  = #VPERM2I128(a[0], a[1], (2u4)[2,0]);
  a0s[0] = a0[0];

  a0[1]  = #VPERM2I128(a[2], a[3], (2u4)[2,0]);
  a0s[1] = a0[1];

  a0s[2] = a[4];

  return a0s;
}

#ifdef EXPORT

export fn rrx_inter1_rr(reg u64 cp ap)
{
  inline int i;
  reg u256[3] a;
  reg u256[5] c;

  for i=0 to 3
  { a[i] = (u256)[ap + 32*i]; }
  c = __rrx_inter1_rr(a);

  for i=0 to 5
  { (u256)[cp + 32*i] = c[i]; }
}

export fn rrx_inter2_rss(reg u64 cp ap bp)
{
  inline int i;
  reg u256 av bv;
  stack u256[3] a b;
  reg u256[5] c;

  for i=0 to 3
  { av = (u256)[ap + 32*i];
    a[i] = av;
    bv = (u256)[bp + 32*i];
    b[i] = bv;
  }
  c = __rrx_inter2_rss(a,b);

  for i=0 to 5
  { (u256)[cp + 32*i] = c[i]; }
}

export fn rrx_deinter_rrr(reg u64 ap bp cp)
{
  inline int i;
  reg u256[3] a b;
  reg u256[5] c;

  for i=0 to 5
  { c[i] = (u256)[cp + 32*i]; }

  a, b = __rrx_deinter_rrr(c);

  for i=0 to 3
  { (u256)[ap + 32*i] = a[i];
    (u256)[bp + 32*i] = b[i];
  }
}

#endif

#endif

