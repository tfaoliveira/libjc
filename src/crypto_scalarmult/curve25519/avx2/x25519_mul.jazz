#ifndef X25519_MUL
#define X25519_MUL

u256 g_times_19 = (4u64)[19, 19, 19, 19];
u256 g_sh_0     = (4u64)[0, 1, 0, 1];
u256 g_sh_1     = (4u64)[1, 0, 1, 0];
u256[2] g_sh_01 = {
  (4u64)[0, 1, 0, 1],
  (4u64)[1, 0, 1, 0]
};

// function __mul_rss returns a*b
//
// let b is stored in B[10..14]. if we consider b to contain the following:
//   c1  c2   d1  d2
//   c3  c4   d3  d4
//   c5  c6   d5  d6
//   c7  c8   d7  d8
//   c9  c10  d9  d10
//
// B[0..4] will provide space to store:
//   c1*19  c2*19   d1*19  d2*19
//   c3*19  c4*19   d3*19  d4*19
//   c5*19  c6*19   d5*19  d6*19
//   c7*19  c8*19   d7*19  d8*19
//   c9*19  c10*19  d9*19  d10*19
//
// and B[5..9]:
//   c2*19   c1  d2*19   d1
//   c4*19   c3  d4*19   d3
//   c6*19   c5  d6*19   d5
//   c8*19   c7  d8*19   d7
//   c10*19  c9  d10*19  d9

inline fn __mul_shufd(inline int idx) -> inline u8
{
  inline u8 ctrl;
  ctrl = 0x44;
  if(idx > 4){ ctrl = 0xEE; }
  return ctrl;
}

inline fn __mul_rss(stack u256[5] _a, stack u256[15] _B) -> reg u256[5], stack u256[15]
{
  inline int i j;
  inline u8 ctrl1 ctrl2;
  reg u256 ai aj t0 t1 t19;
  reg u256[5] d e t c k;
  reg u256[15] B;
  reg u256[2] sh_01;

  // init _B[0..9]
  t19 = g_times_19;
  B[10+4] = _B[10+4];
  for i=4 downto -1 // 4,3,2,1,0
  { B[10+i-1] = _B[10+i-1]; // prefetch
    e[i] = #VPMULU_256(t19, B[10+i]);

    t0   = #VPSLLDQ_256(B[10+i], 8);
    d[i] = #VPSRLDQ_256(e[i], 8);
    d[i] |= t0;

    //d[i] = #VPALIGNR(B[10+i], e[i], 8); // TODO TEST WITH THIS INSTRUCTION
    //d[i] = #VSHUFPD_256(B[10+i], e[i], 4u1[0,1,0,1]); // AND THIS ONE

    _B[i] = e[i];
    _B[5+i] = d[i];
  }

  // i= 0
  ai = #VPSHUFD_256(_a[0],0x44);
  aj = #VPSHUFD_256(_a[1],0x44);
  for j=4 downto -1
  { c[j] = #VPMULU_256(ai, B[10+j]);
    k[j] = #VPMULU_256(aj, B[9+j]);
  }

  // i= 1..4
  for i=1 to 5
  { ctrl1 = __mul_shufd(i*2);
    ctrl2 = __mul_shufd(i*2+1);
    ai = #VPSHUFD_256(_a[(i*2  ) % 5], ctrl1);
    aj = #VPSHUFD_256(_a[(i*2+1) % 5], ctrl2);
    for j=4 downto -1
    { t0 = #VPMULU_256(ai, _B[10+j- i*2]);
      t1 = #VPMULU_256(aj, _B[9+j - i*2]);
      c[j] +4u64= t0;
      k[j] +4u64= t1;
    }
  }

  sh_01 = g_sh_01;
  for i=0 to 5
  { t[i] = #VPSLLV_4u64(k[i], sh_01[i % 2]);
    c[i] +4u64= t[i];
  }

  return c, _B;
}

inline fn __mul_rmm(reg u64 _a, reg u64 _B) -> reg u256[5]
{
  inline int i j;
  inline u8 ctrl1 ctrl2;
  reg u256 ai aj t0 t1 t19;
  reg u256[5] d e t c k;
  reg u256[15] B;
  reg u256[2] sh_01;

  // init _B[0..9]
  t19 = g_times_19;
  B[10+4] = (u256)[_B + 32*(10+4)]; /*_B[10+4];*/
  for i=4 downto -1 // 4,3,2,1,0
  { B[10+i-1] = (u256)[_B + 32*(10+i-1)]; /*_B[10+i-1];*/ // prefetch
    e[i] = #VPMULU_256(t19, B[10+i]);

    t0   = #VPSLLDQ_256(B[10+i], 8);
    d[i] = #VPSRLDQ_256(e[i], 8);
    d[i] |= t0;

    //d[i] = #VPALIGNR(B[10+i], e[i], 8); // TODO TEST WITH THIS INSTRUCTION
    //d[i] = #VSHUFPD_256(B[10+i], e[i], 4u1[0,1,0,1]); // AND THIS ONE

    /*_B[i]*/   (u256)[_B + 32*i] = e[i];
    /*_B[5+i]*/ (u256)[_B + 32*(5+i)] = d[i];
  }

  // i= 0
  ai = #VPSHUFD_256((u256)[_a + 32*0],0x44);
  aj = #VPSHUFD_256((u256)[_a + 32*1],0x44);
  for j=4 downto -1
  { c[j] = #VPMULU_256(ai, B[10+j]);
    k[j] = #VPMULU_256(aj, B[9+j]);
  }

  // i= 1..4
  for i=1 to 5
  { ctrl1 = __mul_shufd(i*2);
    ctrl2 = __mul_shufd(i*2+1);
    ai = #VPSHUFD_256((u256)[_a + 32*((i*2  ) % 5)], ctrl1);
    aj = #VPSHUFD_256((u256)[_a + 32*((i*2+1) % 5)], ctrl2);
    for j=4 downto -1
    { t0 = #VPMULU_256(ai, (u256)[_B + 32*(10+j- i*2)]/*_B[10+j- i*2]*/);
      t1 = #VPMULU_256(aj, (u256)[_B + 32*(9+j - i*2)]/*_B[9+j - i*2]*/);
      c[j] +4u64= t0;
      k[j] +4u64= t1;
    }
  }

  sh_01 = g_sh_01;
  for i=0 to 5
  { t[i] = #VPSLLV_4u64(k[i], sh_01[i % 2]);
    c[i] +4u64= t[i];
  }

  return c;
}

#ifdef EXPORT

export fn mul_rss(reg u64 cp ap bp)
{
  inline int i;
  reg u256 z t1 t2;
  reg u256[5] cr;
  stack u256[5] as;
  stack u256[15] bs;

  z = #set0_256();
  for i=0 to 5
  { t1 = (u256)[ap + 32*i];
    t2 = (u256)[bp + 32*i];
    as[i] = t1;
    bs[i] = z;
    bs[5+i] = z;
    bs[10+i] = t2;
  }
  cr, bs = __mul_rss(as, bs);

  for i=0 to 5
  { (u256)[cp + 32*i] = cr[i]; }
}

export fn mul_rmm(reg u64 cp ap bp)
{
  inline int i;
  reg u256[5] cr;
  cr = __mul_rmm(ap, bp);
  for i=0 to 5
  { (u256)[cp + 32*i] = cr[i]; }
}

#endif

#endif
