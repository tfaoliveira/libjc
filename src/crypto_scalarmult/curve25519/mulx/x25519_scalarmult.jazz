#ifndef X25519_SCALARMULT
#define X25519_SCALARMULT

#include "x25519_add.jazz"
#include "x25519_sub.jazz"
#include "x25519_mul_a24.jazz"
#include "x25519_mul.jazz"
#include "x25519_sqr.jazz"
#include "x25519_invert.jazz"
#include "x25519_tobytes.jazz"
#include "x25519_cswap.jazz"

fn ith_bit(stack u8[32] k, reg u64 ctr) -> reg u64
{
  reg u64 p bit;

  p = ctr;
  p >>= 3;
  bit = (64u) k[(int) p];

  p = ctr;
  p &= 7;
  bit >>= p;

  bit &= 1;

  return bit;
}

fn decode_scalar_25519(reg u64 kp) -> stack u8[32]
{
  inline int i;
  stack u8[32] k;
  reg u64 t;

  for i=0 to 4
  { t = [kp + 8*i];
    k[u64 i] = t; }

  k[0]  &= 0xf8;
  k[31] &= 0x7f;
  k[31] |= 0x40;

  return k;
}

fn decode_u_coordinate(reg u64 up) -> reg u64[4]
{
  inline int i;
  reg u64[4] u;

  for i=0 to 4
  { u[i] = [up + 8*i]; }
  u[3] &= 0x7fffffffffffffff;

  return u;
}

fn init_points(reg u64[4] initr) -> stack u64[4], reg u64[4], stack u64[4], stack u64[4]
{
  inline int i;
  stack u64[4] x2 x3 z3;
  reg u64[4] z2r;
  reg u64 z;

  z = #set0();

  x2[0] = 1;
  z2r[0] = 0;
  x3 = initr;
  z3[0] = 1;

  for i=1 to 4
  { x2[i] = z;
    z2r[i] = z;
    z3[i] = z; }

  //     (1,   0, init, 1)
  return x2, z2r, x3,  z3;
}

fn add_and_double(stack u64[4] init,
                  stack u64[4] x2,
                  reg   u64[4] z2r,
                  stack u64[4] x3,
                  stack u64[4] z3) -> stack u64[4],
                                      reg   u64[4],
                                      stack u64[4],
                                      stack u64[4]
{
  stack u64[4] z2 t0 t1 t2;
  reg u64[4] t1r;

  t0  = _fe64_sub_ssr(x2, z2r);
  x2  = _fe64_add_ssr(x2, z2r);

  t1  = _fe64_sub_sss(x3, z3);
  z2  = _fe64_add_sss(x3, z3);

  z3  = _fe64_mul_sss(x2, t1);
  z2  = _fe64_mul_sss(z2, t0);

  t2  = _fe64_sqr_ss(x2);
  t1r = _fe64_sqr_rs(t0);

  x3  = _fe64_add_sss(z3, z2);
  z2  = _fe64_sub_sss(z3, z2);

  x2  = _fe64_mul_ssr(t2, t1r);
  t0  = _fe64_sub_ssr(t2, t1r);

  z2  = _fe64_sqr_ss(z2);
  z3  = _fe64_mul_a24_ss(t0, 121665);
  x3  = _fe64_sqr_ss(x3);

  t2  = _fe64_add_sss(t2, z3);
  z3  = _fe64_mul_sss(init, z2);
  z2r = _fe64_mul_rss(t0, t2);

  return x2, z2r, x3, z3;
}

fn montgomery_ladder_step(stack u8[32] k,
                          stack u64[4] init,
                          stack u64[4] x2,
                          reg   u64[4] z2r,
                          stack u64[4] x3,
                          stack u64[4] z3,
                          stack u64    swapped,
                          reg   u64    ctr) -> stack u64[4],
                                               reg   u64[4],
                                               stack u64[4],
                                               stack u64[4],
                                               stack u64
{
  reg u64 toswap bit;

  bit = ith_bit(k, ctr);

  toswap  = swapped;
  toswap ^= bit;

  x2, z2r, x3, z3 = _fe64_cswap(x2, z2r, x3, z3, toswap);
  swapped = bit;

  x2, z2r, x3, z3 = add_and_double(init, x2, z2r, x3, z3);

  return x2, z2r, x3, z3, swapped;
}


fn montgomery_ladder(reg u64[4] initr, stack u8[32] k) -> stack u64[4],
                                                          reg u64[4],
                                                          stack u64[4],
                                                          stack u64[4]
{
  stack u64[4] init x2 x3 z3;
  reg u64[4] z2r;
  stack u64 ctrs swapped;
  reg u64 ctr bit;

  (x2,z2r,x3,z3) = init_points(initr); 
  init = initr;

  ctr = 254;
  swapped = 0;

  while
  {
    ctrs = ctr;

    (x2, z2r, x3, z3, swapped) = montgomery_ladder_step(k, init, x2, z2r, x3, z3, swapped, ctr);

    ctr = ctrs;
    ctr -= 1;
  } (ctr >=s 0)

  return x2, z2r, x3, z3;
}

fn encode_point(stack u64[4] x2, reg u64[4] z2r) -> reg u64[4]
{
  reg u64[4] r;

  z2r = _fe64_invert(z2r);
  r = _fe64_mul_rsr(x2, z2r);
  r = _fe64_tobytes(r);

  return r;
}

fn _x25519_scalarmult(
  reg u64 rp,
  reg u64 kp,
  reg u64 up
)
{
  inline int i;
  stack u8[32] k;
  stack u64[4] x2 x3 z3;
  reg u64[4] u z2r r;
  reg u64 swap pos b;
  stack u64 rps swaps poss;

  rps = rp; // rp dead

  k = decode_scalar_25519(kp); // kp dead
  u = decode_u_coordinate(up); // up dead
  (x2,z2r,x3,z3) = montgomery_ladder(u, k);
  r = encode_point(x2,z2r);

  rp = rps;
  for i=0 to 4
  { [rp + 8*i] = r[i]; }
}

#endif
