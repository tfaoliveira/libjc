#ifndef CRYPTO_SCALARMULT_X25519_MULX_REDUCE
#define CRYPTO_SCALARMULT_X25519_MULX_REDUCE

// we need to reduce h such that (read comments from x25519_mul.jazz for context):
//
// h =        2**0*h0 + 2**64*h1 + 2**128*h2 + 2**192*h3 +
//     38 * ( 2**0*h4 + 2**64*h5 + 2**128*h6 + 2**192*h7 )
//
// this will yield 5 limbs:
//
// h = 2**0*h0 + 2**64*h1 + 2**128*h2 + 2**192*h3 + 2**256*h4
//
// so h4 should be multiplied by 38 and we should perform an add-carry chain
// - if it propagates a carry until the end: this last bit should be multiplied
//   by 38 and then added to h0 (if the carry happens then, h0 has space left
//   to hold another addition by 38)
//
// in summary : 
//
// h0 += 38*h4_l
// h1 += 38*h4_h
// h1 += 38*h5_l
// h2 += 38*h5_h
// h2 += 38*h6_l
// h3 += 38*h6_h
// h3 += 38*h7_l // if h7 is 2**64-1 then 2**64-1 * 38 will be 0x25_ffff_ffff_ffff_ffda
// h4  = 38*h7_h // the highest limb of 38*h7_h is at most 0x25 which fits in 6 bits
//
// h0 += h4 * 38 // 0x25 is 37 decimal, multiplied by 38, 1406, which fits in 11 bits
//               // worst case scenario: this addition causes 2**256 to be set (by carry
//               // propagation): then h0 is at most 1405 (and has 11 bits at most: thus)
//               // it can handle another addition by 38
// ... 
//
//
// this function returns the input array but only the first 4 limbs should be
// considered

inline fn __fe64_reduce
( reg u64[4] h,
  reg u64[4] r,
  reg u64 _38,
  reg u64 z, // zero
  reg bool cf of // cf = 0 and of = 0
) -> reg u64[4]
{
  inline int i;
  reg u64 hi lo;

  //
  ( hi, lo )   = #MULX ( _38,  r[0] );
  of, h[0]     = #ADOX ( h[0], lo, of );
  cf, h[1]     = #ADCX ( h[1], hi, cf );

  ( hi, lo )   = #MULX ( _38,  r[1] );
  of, h[1]     = #ADOX ( h[1], lo, of );
  cf, h[2]     = #ADCX ( h[2], hi, cf );

  ( hi, lo )   = #MULX ( _38,  r[2] );
  of, h[2]     = #ADOX ( h[2], lo, of );
  cf, h[3]     = #ADCX ( h[3], hi, cf );

  ( r[0], lo ) = #MULX ( _38, r[3] );
  of, h[3]     = #ADOX ( h[3], lo, of );

  cf, r[0]     = #ADCX ( r[0], z, cf ); 
  of, r[0]     = #ADOX ( r[0], z, of );

  //
  _,_,_,_,_,lo = #IMULri ( r[0], 38 );

  cf, h[0] += lo;
  cf, h[1] += z + cf;
  cf, h[2] += z + cf;
  cf, h[3] += z + cf;

  // h[0] += (z - cf) & 38;
  _, z -= z - cf; // if cf = 1 then z = 0xFF..FF else z = 0
  z &= 38; // if cf = 1 then z = 38 else z = 0
  h[0] += z; // 

  return h;
}

#endif
