#ifndef CRYPTO_SCALARMULT_X25519_MULX_SCALARMULT1
#define CRYPTO_SCALARMULT_X25519_MULX_SCALARMULT1

#include "crypto_scalarmult/curve25519/common/x25519.jazz"
#include "crypto_scalarmult/curve25519/common/64/x25519_load4.jazz"
#include "crypto_scalarmult/curve25519/common/64/x25519_add4.jazz"
#include "crypto_scalarmult/curve25519/common/64/x25519_cswap4.jazz"
#include "crypto_scalarmult/curve25519/common/64/x25519_sub4.jazz"
#include "crypto_scalarmult/curve25519/common/64/x25519_tobytes4.jazz"

#include "crypto_scalarmult/curve25519/mulx/x25519_mul_a24.jazz"
#include "crypto_scalarmult/curve25519/mulx/x25519_mul.jazz"
#include "crypto_scalarmult/curve25519/mulx/x25519_sqr.jazz"
#include "crypto_scalarmult/curve25519/mulx/x25519_invert.jazz"

inline fn __add_and_double_mulx(
  stack u64[4] init,
  stack u64[4] x2,
  reg   u64[4] z2r,
  stack u64[4] x3,
  stack u64[4] z3) -> stack u64[4],
                      reg   u64[4],
                      stack u64[4],
                      stack u64[4]
{
  stack u64[4] z2 t0 t1 t2;
  reg u64[4] t1r;

  t0  = __sub4_ssr(x2, z2r);
  x2  = __add4_ssr(x2, z2r);

  t1  = __sub4_sss(x3, z3);
  z2  = __add4_sss(x3, z3);

  z3  = __mulx_mul4_sss(x2, t1);
  z2  = __mulx_mul4_sss(z2, t0);

  t2  = __mulx_sqr4_ss(x2);
  t1r = __mulx_sqr4_rs(t0);

  x3  = __add4_sss(z3, z2);
  z2  = __sub4_sss(z3, z2);

  x2  = __mulx_mul4_ssr(t2, t1r);
  t0  = __sub4_ssr(t2, t1r);

  z2  = __mulx_sqr4_ss(z2);
  z3  = __mulx_mul4_a24_ss(t0, 121665);
  x3  = __mulx_sqr4_ss(x3);

  t2  = __add4_sss(t2, z3);
  z3  = __mulx_mul4_sss(init, z2);
  z2r = __mulx_mul4_rss(t0, t2);

  return x2, z2r, x3, z3;
}

inline fn __montgomery_ladder_step_mulx(
  stack u8[32] k,
  stack u64[4] init,
  stack u64[4] x2,
  reg   u64[4] z2r,
  stack u64[4] x3,
  stack u64[4] z3,
  stack u64    swapped,
  reg   u64    ctr) -> stack u64[4],
                       reg   u64[4],
                       stack u64[4],
                       stack u64[4],
                       stack u64
{
  reg u64 toswap bit;

  bit = __ith_bit(k, ctr);

  toswap  = swapped;
  toswap ^= bit;

  x2, z2r, x3, z3 = __cswap4(x2, z2r, x3, z3, toswap);
  swapped = bit;

  x2, z2r, x3, z3 = __add_and_double_mulx(init, x2, z2r, x3, z3);

  return x2, z2r, x3, z3, swapped;
}


inline fn __montgomery_ladder_mulx(reg u64[4] u, stack u8[32] k) -> stack u64[4], reg u64[4]
{
  stack u64[4] us x2 x3 z3;
  reg u64[4] z2r;
  stack u64 ctrs swapped;
  reg u64 ctr;

  (x2,z2r,x3,z3) = __init_points(u); 
  us = u;

  ctr = 255;
  swapped = 0;

  while
  {
    ctr -= 1;
    ctrs = ctr;

    (x2, z2r, x3, z3, swapped) = __montgomery_ladder_step_mulx(k, us, x2, z2r, x3, z3, swapped, ctr);

    ctr = ctrs;
  } (ctr > 0)

  return x2, z2r;
}

inline fn __encode_point_mulx(stack u64[4] x2, reg u64[4] z2r) -> reg u64[4]
{
  reg u64[4] r;

  z2r = __mulx_invert4(z2r);
  r = __mulx_mul4_rsr(x2, z2r);
  r = __tobytes4(r);

  return r;
}

inline fn __x25519_scalarmult_mulx(reg u64 rp kp up)
{
  inline int i;
  stack u8[32] k;
  stack u64[4] x2;
  reg u64[4] u z2r r;
  stack u64 rps;

  rps = rp;
  k = __decode_scalar_25519(kp);
  u = __decode_u_coordinate(up);
  (x2,z2r) = __montgomery_ladder_mulx(u, k);
  r = __encode_point_mulx(x2,z2r);

  rp = rps;
  for i=0 to 4
  { [rp + 8*i] = r[i]; }
}

#ifdef EXPORT

export fn curve25519_mulx(reg u64 out scalar point)
{
  __x25519_scalarmult_mulx(out, scalar, point);
}

#endif

#endif
