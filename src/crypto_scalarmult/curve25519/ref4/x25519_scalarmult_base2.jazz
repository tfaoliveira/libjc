#ifndef CRYPTO_SCALARMULT_X25519_REF4_SCALARMULT_BASE2
#define CRYPTO_SCALARMULT_X25519_REF4_SCALARMULT_BASE2

#include "crypto_scalarmult/curve25519/ref4/x25519_scalarmult.jazz"

inline fn __1_x3() -> stack u64[4], reg u64[4], stack u64[4]
{
  inline int i;
  stack u64[4] f1s f3s;
  reg   u64[4] f2;
  reg   u64 z;

  z = #set0();

  f1s[0] = 1;
  f2[0]  = 1;
  f3s[0] = 1;

  for i=1 to 4
  { f1s[i] = z;
    f2[i]  = z;
    f3s[i] = z;
  }

  return f1s, f2, f3s;
}

// "How to (pre-)compute a ladder"
// implementation in C: https://github.com/armfazh/rfc7748_precomputed
inline fn __x25519_scalarmult_base_ref4(
  reg u64 out,
  reg u64 scalar,
  reg u64 table_ladder
)
{
  inline int i;
  stack u64[4] u1 z1 u2 z2 t1 t2 t3 t4;
  reg   u64[4] z1r u2r t1r t2r t3r;
  stack u8[32] e;
  reg u64 t swap pos b;
  stack u64 outs swaps poss;

  stack u64 table_ladder_s; 

  table_ladder_s = table_ladder;

  outs = out; // out dead
  for i=0 to 4
  { t = [scalar + 8*i];
    e[u64 i] = t; } // scalar dead

  e[0]  &= 0xf8;
  e[31] &= 0x7f;
  e[31] |= 0x40;

  u1, z1r, z2 = __1_x3();

	u2r[0] = 0x7e94e1fec82faabd;
	u2r[1] = 0xbbf095ae14b2edf8;
	u2r[2] = 0xadc7a0b9235d48e2;
	u2r[3] = 0x1eaecdeee27cab34;

  u2 = u2r;

  pos = (3 - 3);
  swaps = 1;
  while
  {
    poss = pos;
    swap = swaps;

    pos += 3;
    b = __ith_bit(e, pos);

    swap ^= b;

    u1,  u2 = __cswap_ssss(u1,  u2, swap);
    z1r, z2 = __cswap_rsrs(z1r, z2, swap);

    swaps = b;

    t2    = __sub_ssr(u1, z1r);
    t1    = __add_ssr(u1, z1r);

    table_ladder = table_ladder_s;
    t3r   = __mul_rms(table_ladder, poss, t2);

    t2    = __sub_ssr(t1, t3r);
    t1    = __add_ssr(t1, t3r);

    t1    = __sqr_ss(t1);
    t2    = __sqr_ss(t2);

    u1    = __mul_sss(z2, t1);
    z1r   = __mul_rss(u2, t2);

    pos = poss;
    pos += 1;
  } (pos < (255 - 3))

  pos = 0;
  while
  {
    poss = pos;

    t1  = __add_ssr(u1, z1r);
    t2  = __sub_ssr(u1, z1r);
    t1  = __sqr_ss(t1);
    t2r = __sqr_rs(t2);
    t3  = t2r;

    t2  = __sub_ssr(t1, t2r);
    t4  = __mul_a24_ss(t2, 121666);
    t4  = __add_sss(t4, t3);
    u1  = __mul_sss(t1, t3);
    z1r = __mul_rss(t2, t4);

    pos = poss;
    pos += 1;
  } (pos < 3)

  z1 = z1r;
  t1 = __invert_ss(z1);
  t1r = __mul_rss(u1, t1);
  t1r = __tobytes(t1r);

  out = outs;
  for i=0 to 4
  { [out + 8*i] = t1r[i]; }
}

#ifdef EXPORT

export fn curve25519_ref4_base(reg u64 out scalar table_ladder)
{
  __x25519_scalarmult_base_ref4(out, scalar, table_ladder);
}

#endif

#endif

