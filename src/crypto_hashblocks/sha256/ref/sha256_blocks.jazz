#ifndef CRYPTO_HASHBLOCKS_SHA256_REF
#define CRYPTO_HASHBLOCKS_SHA256_REF

#include "crypto_hashblocks/sha256/ref0/sha256_blocks.jazz"

inline fn __M(stack u32[16] W, inline int i0 i14 i9 i1) -> stack u32[16]
{
  reg u32 t w0 w14 w1;

  // W[i0] += SSIG1(W[i14]) + W[i9] + SSIG0(W[i1]);
  w0  = W[i0];

  w14 = W[i14];
  t   = __sha256_SSIG1(w14);
  w0 += t;

  w0 += W[i9];

  t   = __sha256_SSIG0(W[i1]);
  w0 += t;

  W[i0] = w0;

  return W;
}

inline fn __EXPAND(stack u32[16] W) -> stack u32[16]
{
  inline int i;

  for i=0 to 16
  { W = __M(W, i, (i+14)%16, (i+9)%16, (i+1)%16); }

  return W;
}

// TODO: CHECKME warning extra assignment. For instance: __sha256_BSIG1(r[4]); const in reg?
inline fn __F(reg u32[8] r, stack u32[16] W, inline int wi ki) -> reg u32[8]
{
  reg u32 t T1 T2;
  stack u32 T1s;

  //T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt
  T1  = r[7];
  t   = __sha256_BSIG1(r[4]);
  T1 += t;
  t   = __sha256_CH(r[4],r[5],r[6]);
  T1 += t;
  T1 += SHA256_K[ki];
  T1 += W[wi];
  T1s = T1;

  //T2 = BSIG0(a) + MAJ(a,b,c)
  T2  = __sha256_BSIG0(r[0]);
  t   = __sha256_MAJ(r[0],r[1],r[2]);
  T2 += t;

  r[7]  = r[6];
  r[6]  = r[5];
  r[5]  = r[4];
  r[4]  = r[3];
  r[4] += T1s;
  r[3]  = r[2];
  r[2]  = r[1];
  r[1]  = r[0];
  r[0]  = T1s;
  r[0] += T2;

  return r;
}

inline fn __G(reg u32[8] r, stack u32[16] W, inline int kb) -> reg u32[8]
{
  inline int i;

  for i=0 to 16
  { r = __F(r, W, i, kb+i); }

  return r;
}

#if 0
inline fn __sha256_blocks_ref(stack u32[8] H, reg u64 in inlen) -> stack u32[8], reg u64, reg u64
{
  inline int i;
  reg u32 v;
  reg u32[8] r;
  stack u32[16] W;
  stack u64 in_s;

  r = H;

  in_s = in;
  while(inlen >= 64)
  {
    in = in_s;
    for i=0 to 16
    { v = (u32)[in + i*4];
      v = #BSWAP_32(v);
      W[i] = v;
    }
    //in_s = in;

    for i=0 to 4
    { r = __G(r, W, 16*i);
      if(i < 3)
      { W = __EXPAND(W); }
    }

    for i=0 to 8
    { r[i] += H[i]; }

    H = r;

    //in = in_s;
    //in += 64;
    in_s += 64;
    inlen -= 64;
  }

  in = in_s;
  return H, in, inlen;
}
#endif

#[returnaddress="stack"]
fn _sha256_blocks_ref(reg ptr u32[8] H, reg u64 in inlen) -> reg ptr u32[8], reg u64, reg u64
{
  inline int i;
  reg u32 v;
  reg u32[8] r;
  stack u32[16] W;
  stack ptr u32[8] Hp;
  stack u64 in_s;

  Hp = H;
  r = H;

  in_s = in;
  while(inlen >= 64)
  {
    in = in_s;
    for i=0 to 16
    { v = (u32)[in + i*4];
      v = #BSWAP_32(v);
      W[i] = v;
    }
    //in_s = in;

    for i=0 to 4
    { r = __G(r, W, 16*i);
      if(i < 3)
      { W = __EXPAND(W); }
    }

    H = Hp;
    for i=0 to 8
    { r[i] += H[i]; }

    H = r;
    Hp = H;

    //in = in_s;
    //in += 64;
    in_s += 64;
    inlen -= 64;
  }

  in = in_s;
  return H, in, inlen;
}

#ifdef EXPORT

export fn sha256_blocks_ref(reg u64 pH in _inlen) -> reg u64
{
  stack u32[8] H;
  stack u64 pHs;
  reg u64 inlen;

  // load H
  pHs = pH;
  H = __sha256_load_H_mem(pH);

  // swap inlen register
  inlen = _inlen;
  H, in, inlen = _sha256_blocks_ref(H, in, inlen);

  // restore pointer
  pH = pHs;
  __sha256_store_H_mem(pH, H);

  return inlen;
}

#endif

#endif
