#ifndef SHA256_BLOCKS_INPLACE
#define SHA256_BLOCKS_INPLACE

#include "crypto_hashblocks/sha256/ref0/sha256_blocks.jazz"
#include "crypto_hashblocks/sha256/ref/sha256_blocks.jazz"

inline fn F1(reg u32[8] r, stack u32[16] W, inline int rb wb kb) -> reg u32[8]
{
  inline int i0 i1 i2 i3 i4 i5 i6 i7;
  reg u32 t;

  // statically resolved
  i0 = (rb + 0) % 8;
  i1 = (rb + 1) % 8;
  i2 = (rb + 2) % 8;
  i3 = (rb + 3) % 8;
  i4 = (rb + 4) % 8;
  i5 = (rb + 5) % 8;
  i6 = (rb + 6) % 8;
  i7 = (rb + 7) % 8;

  // r7 += BSIG1(r4) + CH(r4,r5,r6) + K[kb] + W[wb];
  t = BSIG1(r[i4]);
  r[i7] += t;
  t = CH(r[i4], r[i5], r[i6]);
  r[i7] += t;
  r[i7] += K[kb];
  r[i7] += W[wb];

  // r3 += r7;
  r[i3] += r[i7];

  // r7 += BSIG0(r0) + MAJ(r0,r1,r2);
  t = BSIG0(r[i0]);
  r[i7] += t;

  t = MAJ(r[i0], r[i1], r[i2]);
  r[i7] += t;

  return r;
}

inline fn G1(reg u32[8] r, stack u32[16] W, inline int kb) -> reg u32[8]
{
  inline int i;

  for i=0 to 16
  { r = F1(r, W, ((16-i) % 8), i, kb+i); }

  return r;
}

inline fn _sha256_blocks_inplace(stack u32[8] H, reg u64 in inlen) -> stack u32[8], reg u64, reg u64
{
  inline int i, j;
  reg u32[8] r;
  stack u32[16] W;

  r = H;

  while(inlen >= 64)
  {
    for i=0 to 16
    { W[i] = load_bigendian(in, i*4); }

    for i=0 to 4
    { 
      r = G1(r, W, 16*i);
      if(i < 3)
      { W = EXPAND(W); }
    }

    for i=0 to 8
    { r[i] += H[i]; }

    H = r;

    in += 64;
    inlen -= 64;
  }

  return H, in, inlen;
}

#endif
