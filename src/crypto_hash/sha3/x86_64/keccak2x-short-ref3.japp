
/* New pseudo instuctions */
#define ANDN(x,y) !(x) & (y)
/*
fn ANDN(reg u64 x, reg u64 y) -> reg u64 {
  reg u64 r;
  _, _, _, _, _, r = #x86_ANDN(x, y);
  return r;
}
*/

fn ROL64(reg u64 x, inline int c) -> reg u64 {
  reg u64 y;
  _, _, y = #x86_ROL_64(x, c);
  if c==0 { y = x; }
  return y;
}

/* State access function
   remark: base address has an offset of 100 bytes. */
#define S(base,x,y) [base + 8*(5*((x) % 5) + ((y) % 5)) - 100]

fn keccakRhoOffsets(inline int i) -> inline int {
inline int r, x, y, z, t;

  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24 {
    if i == x + 5 * y {
      r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}

fn rhotates(inline int x y) -> inline int {
  inline int i r;
  i = 5*(x%5) + (y%5);
  r = keccakRhoOffsets(i);
  return r;
}

/*
    Round functions
*/

fn wrap1(reg u64 x0 x1 x2 x3 x4 y0 y1 y2 y3 y4)
   -> reg u64[5], reg u64[5] {
  reg u64[5] X Y;
  X[0] = x0;
  X[1] = x1;
  X[2] = x2;
  X[3] = x3;
  X[4] = x4;
  Y[0] = y0;
  Y[1] = y1;
  Y[2] = y2;
  Y[3] = y3;
  Y[4] = y4;
  return X,Y;
}

#define PRESERVR(k, X, p) for i = 0 to k {X[i] = [p+8*i]; }
#define PRESERVW(k, X, p) for i = 0 to k {[p+8*i] = X[i]; }
/*
fn preservR(reg u64 p) -> reg u64[2] {
 inline int i;
 reg u64[2] X;
 for i = 0 to 2 { X[i] = [p + 8*i]; }
 return X;
}

fn preservW(reg u64[2] X, reg u64 p) {
 inline int i;
 for i = 0 to 2 { [p + 8*i] = X[i]; }
}
*/

fn preservW5(reg u64[5] X, reg u64 p) {
 inline int i;
 for i = 0 to 5 { [p + 8*i] = X[i]; }
}

// https://github.com/openssl/openssl/blob/master/crypto/sha/keccak1600.c
fn round2x_short(reg u64 A R iotas) /* -> reg u64 */ {
  inline int i;
  reg u64[5] L C D;
  reg u64 T0; // T1 T2 T3 T4;
  reg bool zf;

  // não percebo como não existe mais folga !!!
  reg u64[2] P;
  PRESERVR(1, P, iotas)

  // L is C passed over loop iterations
  L[0] = S(A,4,0);
  L[1] = S(A,4,1);
  L[2] = S(A,4,2);
  L[3] = S(A,4,3);
  L[4] = S(A,4,4);

  // ROUND LOOP
  while {
    // obs: C[j] == S(A,4,j)
    D[0] = S(A,0,0);
    D[1] = S(A,1,1);
    D[2] = S(A,2,2);
    D[3] = S(A,3,3);
    D[4] = L[4];

    // Desacoplar L e C
    C[2] = S(A,0,2);	// C[2] = A[0,4][2]
    C[2] ^= L[2];	// C[2] = A[0,4][2]
    C[3] = S(A,0,3);	// C[3] = A[0,4][3]
    C[3] ^= L[3];	// C[3] = A[0,4][3]
    C[0] = S(A,1,0);	// C[0] = A[0..1,4][0]
    C[0] ^= L[0];	// C[0] = A[0..1,4][0]
    C[0] ^= D[0];    	// C[0] = A[0,4][0]
    C[1] = S(A,0,1);	// C[1] = A[0,4][1]
    C[1] ^= L[1];	// C[1] = A[0,4][1]
    C[2] ^= S(A,1,2);	// C[2] = A[0..1,4][2]

    C[4] = S(A,0,4);	// C[4] = A[0,4][4]
    C[4] ^= L[4];	// C[4] = A[0,4][4]
    C[2] ^= D[2];	// C[2] = A[0..2,4][2]
    C[0] ^= S(A,2,0);	// C[0] = A[0..2,4][0]
    C[3] ^= S(A,1,3);	// C[3] = A[0,3..4][3]
    C[1] ^= D[1];	// C[1] = A[0..1,4][1]
    C[4] ^= S(A,1,4);	// C[4] = A[0..1,4][4]
    C[2] ^= S(A,3,2);	// C[2] = A[0..4][2] *
    C[0] ^= S(A,3,0);	// C[0] = A[0..4][0] *
    C[3] ^= S(A,2,3);	// C[3] = A[0,2..4][3]
    C[1] ^= S(A,2,1);	// C[1] = A[0..2,4][1]
    C[4] ^= S(A,2,4);	// C[4] = A[0..2,4][4]

    T0 = C[2];
    C[2] = ROL64(C[2], 1);
    C[2] ^= C[0];    	// C[2] = ROL64(C[2], 1) ^ C[0]  // (D[1])
    C[3] ^= D[3]; 	// C[3] = A[0..4][3] *
    C[0] = ROL64(C[0], 1);
    C[0] ^= C[3];	// C[0] = ROL64(C[0], 1) ^ C[3]  // (D[4])
    C[1] ^= S(A,3,1);	// C[1] = A[0..4][4] *
    C[3] = ROL64(C[3], 1);
    C[3] ^= C[1];	// C[3] = ROL64(C[3], 1) ^ C[1]  // (D[2])
    C[4] ^= S(A,3,4);	// C[4] = A[0..4][4] *
    C[1] = ROL64(C[1], 1);
    C[1] ^= C[4];	// C[1] = ROL64(C[1], 1) ^ C[4]  // (D[0])
    C[4] = ROL64(C[4], 1);
    C[4] ^= T0;       // C[4] = ROL64(C[4], 1) ^ (C[2])  // (D[3])

    C, D = wrap1(D[0],D[1],D[2],D[3],D[4],C[1],C[2],C[3],C[4],C[0]);

    // Row 0
    //r = 0;
        C[0] ^= D[(3*0+0)%5];
	i = rhotates(0,3*0+0);
	C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*0+1)%5];
	i = rhotates(1,3*0+1);
	C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*0+2)%5];
	i = rhotates(2,3*0+2);
	C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*0+3)%5];
	i = rhotates(3,3*0+3);
	C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*0+4)%5];
	i = rhotates(4,3*0+4);
	C[4] = ROL64(C[4], i);

        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
	T0 ^= C[0];
        T0 ^= [iotas+0];
	iotas += 8;
	S(R,0,0) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
	T0 ^= C[1];
	S(R,0,1) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
	T0 ^= C[2];
	S(R,0,2) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
	T0 ^= C[3];
	S(R,0,3) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
	T0 ^= C[4];
	S(R,0,4) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        C[0] = S(A,0,3*(0+1)+0);
        C[1] = S(A,1,3*(0+1)+1);
        C[2] = S(A,2,3*(0+1)+2);
        C[3] = S(A,3,3*(0+1)+3);
        C[4] = S(A,4,3*(0+1)+4);

    // Row 1
    //r = 1;

        C[0] ^= D[(3*1+0)%5];
	i = rhotates(0,3*1+0);
	C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*1+1)%5];
	i = rhotates(1,3*1+1);
	C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*1+2)%5];
	i = rhotates(2,3*1+2);
	C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*1+3)%5];
	i = rhotates(3,3*1+3);
	C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*1+4)%5];
	i = rhotates(4,3*1+4);
	C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
	T0 ^= C[0];
	S(R,1,0) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
	T0 ^= C[1];
	S(R,1,1) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
	T0 ^= C[2];
	S(R,1,2) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
	T0 ^= C[3];
	S(R,1,3) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
	T0 ^= C[4];
	S(R,1,4) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = S(A,0,3*(1+1)+0);
        C[1] = S(A,1,3*(1+1)+1);
        C[2] = S(A,2,3*(1+1)+2);
        C[3] = S(A,3,3*(1+1)+3);
        C[4] = S(A,4,3*(1+1)+4);


    // Row 2
    //r = 2;

        C[0] ^= D[(3*2+0)%5];
	i = rhotates(0,3*2+0);
	C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*2+1)%5];
	i = rhotates(1,3*2+1);
	C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*2+2)%5];
	i = rhotates(2,3*2+2);
	C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*2+3)%5];
	i = rhotates(3,3*2+3);
	C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*2+4)%5];
	i = rhotates(4,3*2+4);
	C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
	T0 ^= C[0];
	S(R,2,0) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
	T0 ^= C[1];
	S(R,2,1) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
	T0 ^= C[2];
	S(R,2,2) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
	T0 ^= C[3];
	S(R,2,3) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
	T0 ^= C[4];
	S(R,2,4) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = S(A,0,3*(2+1)+0);
        C[1] = S(A,1,3*(2+1)+1);
        C[2] = S(A,2,3*(2+1)+2);
        C[3] = S(A,3,3*(2+1)+3);
        C[4] = S(A,4,3*(2+1)+4);

    // Row 3
    //r = 3;

        C[0] ^= D[(3*3+0)%5];
	i = rhotates(0,3*3+0);
	C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*3+1)%5];
	i = rhotates(1,3*3+1);
	C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*3+2)%5];
	i = rhotates(2,3*3+2);
	C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*3+3)%5];
	i = rhotates(3,3*3+3);
	C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*3+4)%5];
	i = rhotates(4,3*3+4);
	C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
	T0 ^= C[0];
	S(R,3,0) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
	T0 ^= C[1];
	S(R,3,1) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
	T0 ^= C[2];
	S(R,3,2) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
	T0 ^= C[3];
	S(R,3,3) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
	T0 ^= C[4];
	S(R,3,4) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = S(A,0,3*(3+1)+0);
        C[1] = S(A,1,3*(3+1)+1);
        C[2] = S(A,2,3*(3+1)+2);
        C[3] = S(A,3,3*(3+1)+3);
        C[4] = S(A,4,3*(3+1)+4);

    // Row 4
    //r = 4;

        C[0] ^= D[(3*4+0)%5];
	i = rhotates(0,3*4+0);
	C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*4+1)%5];
	i = rhotates(1,3*4+1);
	C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*4+2)%5];
	i = rhotates(2,3*4+2);
	C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*4+3)%5];
	i = rhotates(3,3*4+3);
	C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*4+4)%5];
	i = rhotates(4,3*4+4);
	C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
	T0 ^= C[0];
	S(R,4,0) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
	T0 ^= C[1];
	S(R,4,1) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
	T0 ^= C[2];
	S(R,4,2) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
	T0 ^= C[3];
	S(R,4,3) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
	T0 ^= C[4];
	S(R,4,4) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]



    // prepare next round
    // swap A and R
    T0 = A;
    A = R;
    R = T0;

        L[0] = S(A,4,0);
        L[1] = S(A,4,1);
        L[2] = S(A,4,2);
        L[3] = S(A,4,3);
        L[4] = S(A,4,4);

    _, _, _, _, zf = #x86_TEST_8(iotas,255);
  } (!zf)

  //preservW5(C, R);
  PRESERVW(1, P, R)

}


export fn keccakF_short(reg u64 A R iotas) {
  A += 100;
  R += 100;
  round2x_short(A, R, iotas);
}
