
/* New pseudo instuctions */
fn ANDN(reg u64 x, reg u64 y) -> reg u64 {
  reg u64 r;
  _, _, _, _, _, r = #x86_ANDN(x, y);
  return r;
}

fn ROL64(reg u64 x, inline int c) -> reg u64 {
  reg u64 y;
  _, _, y = #x86_ROL_64(x, c);
  if c==0 { y = x; }
  return y;
}

/* State access function
   remark: base address has an offset of 100 bytes.

fn S(reg u64 base, inline int x, inline int y) -> reg u64 {
  reg u64 r;
  inline int i;
  i = -100 + 5*(x % 5) + (y % 5);
  r = [base + i];
  return r;
}
*/
/*
inline fn Sidx(inline int x y) -> inline int {
  inline int r;
  r = 5*(x % 5) + (y % 5) - 100;
  return r;
}
*/
#define S(base,x,y) [base + 8*(5*(x % 5) + (y % 5)) - 100]
/*
fn W(reg u64 base, inline int x, inline int y, reg u64 v) {
  inline int i;
  i = -100 + 5*(x % 5) + (y % 5);
  [base + i] = v;
}
*/

fn keccakRhoOffsets(inline int i) -> inline int {
inline int r, x, y, z, t;

  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24 {
    if i == x + 5 * y {
      r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}

fn rhotates(inline int x y) -> inline int {
  inline int i r;
  i = 5*(x%5) + (y%5);
  r = keccakRhoOffsets(i);
  return r;
}

/*
    Round functions
*/

fn wrap1(reg u64 x0 x1 x2 x3 x4 y0 y1 y2 y3 y4)
   -> reg u64[5], reg u64[5] {
  reg u64[5] X Y;
  X[0] = x0;
  X[1] = x1;
  X[2] = x2;
  X[3] = x3;
  X[4] = x4;
  Y[0] = y0;
  Y[1] = y1;
  Y[2] = y2;
  Y[3] = y3;
  Y[4] = y4;
  return X,Y;
}

// https://github.com/openssl/openssl/blob/master/crypto/sha/keccak1600.c
fn round2x_short(reg u64 A R iotas) /* -> reg u64 */ {
  inline int r j i;
  reg u64[5] C D;
  reg u64 T0;
  reg bool zf;

  C[0] = S(A,4,0);
  C[1] = S(A,4,1);
  C[2] = S(A,4,2);
  C[3] = S(A,4,3);
  C[4] = S(A,4,4);

  // ROUND LOOP
  while {
    D[0] = S(A,0,0);
    D[1] = S(A,1,1);
    D[2] = S(A,2,2);
    D[3] = S(A,3,3);

    C[2] ^= S(A,0,2);	// C[2] = A[0,4][2]
    C[3] ^= S(A,0,3);	// C[3] = A[0,4][3]
    C[0] ^= D[0];    	// C[0] = A[0,4][0]
    C[1] ^= S(A,0,1);	// C[1] = A[0,4][1]
    C[2] ^= S(A,1,2);	// C[2] = A[0..1,4][2]
    C[0] ^= S(A,1,0);	// C[0] = A[0..1,4][0]

    D[4] = C[4];

    C[4] ^= S(A,0,4);	// C[4] = A[0,4][4]
    C[2] ^= D[2];	// C[2] = A[0..2,4][2]
    C[0] ^= S(A,2,0);	// C[0] = A[0..2,4][0]
    C[3] ^= S(A,1,3);	// C[3] = A[0,3..4][3]
    C[1] ^= D[1];	// C[1] = A[0..1,4][1]
    C[4] ^= S(A,1,4);	// C[4] = A[0..1,4][4]
    C[2] ^= S(A,3,2);	// C[2] = A[0..4][2] *
    C[0] ^= S(A,3,0);	// C[0] = A[0..4][0] *
    C[3] ^= S(A,2,3);	// C[3] = A[0,2..4][3]
    C[1] ^= S(A,2,1);	// C[1] = A[0..2,4][1]
    C[4] ^= S(A,2,4);	// C[4] = A[0..2,4][4]

    T0 = C[2];
    C[2] = ROL64(C[2], 1);
    C[2] ^= C[0];    	// C[2] = ROL64(C[2], 1) ^ C[0]  // (D[1])
    C[3] ^= D[3]; 	// C[3] = A[0..4][3] *
    C[0] = ROL64(C[0], 1);
    C[0] ^= C[3];	// C[0] = ROL64(C[0], 1) ^ C[3]  // (D[4])
    C[1] ^= S(A,3,1);	// C[1] = A[0..4][4] *
    C[3] = ROL64(C[3], 1);
    C[3] ^= C[1];	// C[3] = ROL64(C[3], 1) ^ C[1]  // (D[2])
    C[4] ^= S(A,3,4);	// C[4] = A[0..4][4] *
    C[1] = ROL64(C[1], 1);
    C[1] ^= C[4];	// C[1] = ROL64(C[1], 1) ^ C[4]  // (D[0])
    C[4] = ROL64(C[4], 1);
    C[4] ^= T0;       // C[4] = ROL64(C[4], 1) ^ (C[2])  // (D[3])

    C, D = wrap1(D[0],D[1],D[2],D[3],D[4],C[1],C[2],C[3],C[0],C[4]);

    for r = 0 to 5 {
      // obs: C[j] == S(A,j,3*r+j)

      for j = 0 to 5 {
        C[j] ^= D[j];
	i = rhotates(j,3*r+j);
	C[j] = ROL64(C[j], i);
      }

      for j = 0 to 5 {
        T0 = ANDN(C[(j+1)%5], C[(j+2)%5]);
	T0 ^= C[j];
	if (r==0 && j==0) {
          T0 ^= [iotas+0];
          iotas += 8;
        }
	S(R,r,j) = T0;	//C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]
      }
    }
    // prepare next round
    // swap A and R
    T0 = A;
    A = R;
    R = T0;
    for j = 0 to 5 {
      C[j] = S(A,0,3*(r+1)+j);
    }
    _, _, _, _, zf = #x86_TEST_8(iotas,255);
  } (!zf)

  //iotas -=192;
  //return iotas;
}


export fn keccakF_short(reg u64 A R iotas) {
  A += 100;
  R += 100;
  round2x_short(A, R, iotas);
}
