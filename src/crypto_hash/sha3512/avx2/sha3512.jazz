#ifndef CRYPTO_HASH_SHA3512_AVX2
#define CRYPTO_HASH_SHA3512_AVX2

#ifndef LIBJC
//to support specific implementations for this function we
//need a module feature in Jasmin.
#define KECCAK1600_ADD_FULL_BLOCK_IMPLEMENTATION 1
inline fn __add_full_block_avx2(
  reg u256[7] state,
  stack u64[28] s_state,
  reg ptr u64[25] _not_used_,
  reg u64 in inlen,
  reg u64 rate
) -> reg u256[7], stack u64[28], reg u64, reg u64
{
  reg u256 a00 a10 a01 a11;
  reg u256 t11 t12 t13;
  reg u256 zero;

  zero = #set0_256();

  a00  = #VPBROADCAST_4u64([in + 8*0]); // (0,0) (0,0) (0,0) (0,0)
  a10  = #VPBROADCAST_4u64([in + 8*5]); // (1,0) (1,0) (1,0) (1,0)
  a01  = (u256)[in + 8*1];                  // (0,4) (0,3) (0,2) (0,1)
  a11  = (u256)[in + 8*6];                  // (1,4) (1,3) (1,2) (1,1)

  state[0] ^= a00;
  state[1] ^= a01;

  a01 = #VPBLEND_8u32(a10, zero, (8u1)[1,1,0,0,1,1,1,1]); //  ___  (1,0)  ___   ___
  t12 = #VPBLEND_8u32(a11, zero, (8u1)[1,1,1,1,0,0,1,1]); //  ___   ___  (1,2)  ___
  t13 = #VPBLEND_8u32(a11, zero, (8u1)[1,1,0,0,1,1,1,1]); //  ___  (1,3)  ___   ___
  t11 = #VPBLEND_8u32(a11, zero, (8u1)[1,1,1,1,1,1,0,0]); //  ___   ___   ___  (1,1)

  state[2] ^= a01;
  state[3] ^= t12;
  state[4] ^= t13;
  state[6] ^= t11; 

  in += rate;
  inlen -= rate;

  return state, s_state, in, inlen;
}
#endif

#include "crypto_hash/keccak1600/avx2/keccak1600.jazz"

inline fn __sha3512_avx2(reg u64 out in inlen)
{
  reg u64 outlen rate;
  reg u8 trail_byte;

  outlen = (512/8);
  trail_byte = 0x6;
  rate = (576/8);

  __keccak1600_avx2(out, outlen, in, inlen, trail_byte, rate);
}

#ifdef EXPORT

export fn sha3512_avx2(reg u64 out in inlen)
{
  __sha3512_avx2(out, in, inlen);
}

#endif

#endif
