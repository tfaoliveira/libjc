// TODO refactor iotas when global arrays are supported



          
  fn swap(reg u64 a b) -> reg u64, reg u64
  { reg u64 t;
    t = a; a = b; b = t; // XCHG
    return a, b; }

    


fn spill_2(reg u64 a b) -> stack u64, stack u64
{
  stack u64 sa sb;
  sa = a;
  sb = b;
  return sa, sb;
}



fn load_2(stack u64 sa sb) -> reg u64, reg u64
{
  reg u64 a b;
  a = sa;
  b = sb;
  return a, b;
}






fn ROL64(reg u64 x, inline int c) -> reg u64
{
  reg u64 y;
  if (c == 0)
  { y = x; }
  else
  { _, _, y = #x86_ROL_64(x, c); }
  return y;
}



fn keccak_init(reg u64 m) -> reg u64
{
  reg u64 state;
  reg u64 i t;

  _, _, _, _, _, t = #set0();

    state = m; //if state is in stack this is just ignored
  
  i = 0;
  while (i < 50)
  { [state + 8*(i)] = t;
    i += 1;
  }

  return state;
}



fn index(inline int x, inline int y) -> inline int {
  inline int r;
  r = 5*(x % 5) + (y % 5);
  return r;
}



fn keccak_rho_offsets(inline int i) -> inline int
{
  inline int r, x, y, z, t;
  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24
  { if i == x + 5 * y
    { r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}



fn rhotates(inline int x y) -> inline int
{
  inline int i r;
  i = index(x, y);
  r = keccak_rho_offsets(i);
  return r;
}



fn rename1(reg u64 x0 x1 x2 x3 x4
                   y0 y1 y2 y3 y4
) -> reg u64[5], reg u64[5]
{
  reg u64[5] X Y;
 
  X[0] = x0;
  X[1] = x1;
  X[2] = x2;
  X[3] = x3;
  X[4] = x4;
  Y[0] = y0;
  Y[1] = y1;
  Y[2] = y2;
  Y[3] = y3;
  Y[4] = y4;

  return X, Y;
}



fn keccak_f(
  reg u64 A,
  reg u64 iotas
) -> reg u64, reg u64
{
  // https://github.com/openssl/openssl/blob/master/crypto/sha/keccak1600.c
  inline int i;
  reg bool zf;
  reg u64[5] C D;
  reg u64 T0 T1;
  reg u64 R;

  A += 100;R = A + 200;

  C[0] = [A + 8*(5*((4) % 5) + ((0) % 5)) - 100];
  C[1] = [A + 8*(5*((4) % 5) + ((1) % 5)) - 100];
  C[2] = [A + 8*(5*((4) % 5) + ((2) % 5)) - 100];
  C[3] = [A + 8*(5*((4) % 5) + ((3) % 5)) - 100];
  C[4] = [A + 8*(5*((4) % 5) + ((4) % 5)) - 100];

  // round loop
  align while {
    // obs: C[j] == [A + 8*(5*((4) % 5) + ((j) % 5)) - 100]
    D[0] = [A + 8*(5*((0) % 5) + ((0) % 5)) - 100];
    D[1] = [A + 8*(5*((1) % 5) + ((1) % 5)) - 100];
    D[2] = [A + 8*(5*((2) % 5) + ((2) % 5)) - 100];
    D[3] = [A + 8*(5*((3) % 5) + ((3) % 5)) - 100];

    C[2] ^= [A + 8*(5*((0) % 5) + ((2) % 5)) - 100];    // C[2] = A[0,4][2]
    C[3] ^= [A + 8*(5*((0) % 5) + ((3) % 5)) - 100];    // C[3] = A[0,4][3]
    C[0] ^= D[0];        // C[0] = A[0,4][0]
    C[1] ^= [A + 8*(5*((0) % 5) + ((1) % 5)) - 100];    // C[1] = A[0,4][1]
    C[2] ^= [A + 8*(5*((1) % 5) + ((2) % 5)) - 100];    // C[2] = A[0..1,4][2]
    C[0] ^= [A + 8*(5*((1) % 5) + ((0) % 5)) - 100];    // C[0] = A[0..1,4][0]

    D[4] = C[4];

    C[4] ^= [A + 8*(5*((0) % 5) + ((4) % 5)) - 100];    // C[4] = A[0,4][4]
    C[2] ^= D[2];        // C[2] = A[0..2,4][2]
    C[0] ^= [A + 8*(5*((2) % 5) + ((0) % 5)) - 100];    // C[0] = A[0..2,4][0]
    C[3] ^= [A + 8*(5*((1) % 5) + ((3) % 5)) - 100];    // C[3] = A[0,3..4][3]
    C[1] ^= D[1];        // C[1] = A[0..1,4][1]
    C[4] ^= [A + 8*(5*((1) % 5) + ((4) % 5)) - 100];    // C[4] = A[0..1,4][4]
    C[2] ^= [A + 8*(5*((3) % 5) + ((2) % 5)) - 100];    // C[2] = A[0..4][2] *
    C[0] ^= [A + 8*(5*((3) % 5) + ((0) % 5)) - 100];    // C[0] = A[0..4][0] *
    C[3] ^= [A + 8*(5*((2) % 5) + ((3) % 5)) - 100];    // C[3] = A[0,2..4][3]
    C[1] ^= [A + 8*(5*((2) % 5) + ((1) % 5)) - 100];    // C[1] = A[0..2,4][1]
    C[4] ^= [A + 8*(5*((2) % 5) + ((4) % 5)) - 100];    // C[4] = A[0..2,4][4]

    T0 = C[2];
    C[2] = ROL64(C[2], 1);
    C[2] ^= C[0];        // C[2] = ROL64(C[2], 1) ^ C[0]  // (D[1])
    C[3] ^= D[3];       // C[3] = A[0..4][3] *
    C[0] = ROL64(C[0], 1);
    C[0] ^= C[3];        // C[0] = ROL64(C[0], 1) ^ C[3]  // (D[4])
    C[1] ^= [A + 8*(5*((3) % 5) + ((1) % 5)) - 100];    // C[1] = A[0..4][4] *
    C[3] = ROL64(C[3], 1);
    C[3] ^= C[1];        // C[3] = ROL64(C[3], 1) ^ C[1]  // (D[2])
    C[4] ^= [A + 8*(5*((3) % 5) + ((4) % 5)) - 100];    // C[4] = A[0..4][4] *
    C[1] = ROL64(C[1], 1);
    C[1] ^= C[4];        // C[1] = ROL64(C[1], 1) ^ C[4]  // (D[0])
    C[4] = ROL64(C[4], 1);
    C[4] ^= T0;       // C[4] = ROL64(C[4], 1) ^ (C[2])  // (D[3])

    C, D = rename1(D[0],D[1],D[2],D[3],D[4],C[1],C[2],C[3],C[4],C[0]);

    // Row 0
    //r = 0;
        C[0] ^= D[(3*0+0)%5];
    i = rhotates(0,3*0+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*0+1)%5];
    i = rhotates(1,3*0+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*0+2)%5];
    i = rhotates(2,3*0+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*0+3)%5];
    i = rhotates(3,3*0+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*0+4)%5];
    i = rhotates(4,3*0+4);
    C[4] = ROL64(C[4], i);

        T0 = !(C[(0+1)%5]) & ( C[(0+2)%5]);
        T1 = !(C[(1+1)%5]) & ( C[(1+2)%5]); //%%//
    T0 ^= C[0];
    T1 ^= C[1]; //%%//
        T0 ^= [iotas+0];
    iotas += 8;
    [R + 8*(5*((0) % 5) + ((0) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]
    [R + 8*(5*((0) % 5) + ((1) % 5)) - 100] = T1; //%%//

        T0 = !(C[(2+1)%5]) & ( C[(2+2)%5]);
    T0 ^= C[2];
    [R + 8*(5*((0) % 5) + ((2) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(3+1)%5]) & ( C[(3+2)%5]);
    T0 ^= C[3];
    [R + 8*(5*((0) % 5) + ((3) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(4+1)%5]) & ( C[(4+2)%5]);
    T0 ^= C[4];
    [R + 8*(5*((0) % 5) + ((4) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        C[0] = [A + 8*(5*((0) % 5) + ((3*(0+1)+0) % 5)) - 100];
        C[1] = [A + 8*(5*((1) % 5) + ((3*(0+1)+1) % 5)) - 100];
        C[2] = [A + 8*(5*((2) % 5) + ((3*(0+1)+2) % 5)) - 100];
        C[3] = [A + 8*(5*((3) % 5) + ((3*(0+1)+3) % 5)) - 100];
        C[4] = [A + 8*(5*((4) % 5) + ((3*(0+1)+4) % 5)) - 100];

    // Row 1
    //r = 1;

        C[0] ^= D[(3*1+0)%5];
    i = rhotates(0,3*1+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*1+1)%5];
    i = rhotates(1,3*1+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*1+2)%5];
    i = rhotates(2,3*1+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*1+3)%5];
    i = rhotates(3,3*1+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*1+4)%5];
    i = rhotates(4,3*1+4);
    C[4] = ROL64(C[4], i);


        T0 = !(C[(0+1)%5]) & ( C[(0+2)%5]);
    T0 ^= C[0];
    [R + 8*(5*((1) % 5) + ((0) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(1+1)%5]) & ( C[(1+2)%5]);
    T0 ^= C[1];
    [R + 8*(5*((1) % 5) + ((1) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(2+1)%5]) & ( C[(2+2)%5]);
    T0 ^= C[2];
    [R + 8*(5*((1) % 5) + ((2) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(3+1)%5]) & ( C[(3+2)%5]);
    T0 ^= C[3];
    [R + 8*(5*((1) % 5) + ((3) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(4+1)%5]) & ( C[(4+2)%5]);
    T0 ^= C[4];
    [R + 8*(5*((1) % 5) + ((4) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = [A + 8*(5*((0) % 5) + ((3*(1+1)+0) % 5)) - 100];
        C[1] = [A + 8*(5*((1) % 5) + ((3*(1+1)+1) % 5)) - 100];
        C[2] = [A + 8*(5*((2) % 5) + ((3*(1+1)+2) % 5)) - 100];
        C[3] = [A + 8*(5*((3) % 5) + ((3*(1+1)+3) % 5)) - 100];
        C[4] = [A + 8*(5*((4) % 5) + ((3*(1+1)+4) % 5)) - 100];


    // Row 2
    //r = 2;

        C[0] ^= D[(3*2+0)%5];
    i = rhotates(0,3*2+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*2+1)%5];
    i = rhotates(1,3*2+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*2+2)%5];
    i = rhotates(2,3*2+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*2+3)%5];
    i = rhotates(3,3*2+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*2+4)%5];
    i = rhotates(4,3*2+4);
    C[4] = ROL64(C[4], i);


        T0 = !(C[(0+1)%5]) & ( C[(0+2)%5]);
    T0 ^= C[0];
    [R + 8*(5*((2) % 5) + ((0) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(1+1)%5]) & ( C[(1+2)%5]);
    T0 ^= C[1];
    [R + 8*(5*((2) % 5) + ((1) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(2+1)%5]) & ( C[(2+2)%5]);
    T0 ^= C[2];
    [R + 8*(5*((2) % 5) + ((2) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(3+1)%5]) & ( C[(3+2)%5]);
    T0 ^= C[3];
    [R + 8*(5*((2) % 5) + ((3) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(4+1)%5]) & ( C[(4+2)%5]);
    T0 ^= C[4];
    [R + 8*(5*((2) % 5) + ((4) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = [A + 8*(5*((0) % 5) + ((3*(2+1)+0) % 5)) - 100];
        C[1] = [A + 8*(5*((1) % 5) + ((3*(2+1)+1) % 5)) - 100];
        C[2] = [A + 8*(5*((2) % 5) + ((3*(2+1)+2) % 5)) - 100];
        C[3] = [A + 8*(5*((3) % 5) + ((3*(2+1)+3) % 5)) - 100];
        C[4] = [A + 8*(5*((4) % 5) + ((3*(2+1)+4) % 5)) - 100];

    // Row 3
    //r = 3;

        C[0] ^= D[(3*3+0)%5];
    i = rhotates(0,3*3+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*3+1)%5];
    i = rhotates(1,3*3+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*3+2)%5];
    i = rhotates(2,3*3+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*3+3)%5];
    i = rhotates(3,3*3+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*3+4)%5];
    i = rhotates(4,3*3+4);
    C[4] = ROL64(C[4], i);


        T0 = !(C[(0+1)%5]) & ( C[(0+2)%5]);
    T0 ^= C[0];
    [R + 8*(5*((3) % 5) + ((0) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(1+1)%5]) & ( C[(1+2)%5]);
    T0 ^= C[1];
    [R + 8*(5*((3) % 5) + ((1) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(2+1)%5]) & ( C[(2+2)%5]);
    T0 ^= C[2];
    [R + 8*(5*((3) % 5) + ((2) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(3+1)%5]) & ( C[(3+2)%5]);
    T0 ^= C[3];
    [R + 8*(5*((3) % 5) + ((3) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(4+1)%5]) & ( C[(4+2)%5]);
    T0 ^= C[4];
    [R + 8*(5*((3) % 5) + ((4) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = [A + 8*(5*((0) % 5) + ((3*(3+1)+0) % 5)) - 100];
        C[1] = [A + 8*(5*((1) % 5) + ((3*(3+1)+1) % 5)) - 100];
        C[2] = [A + 8*(5*((2) % 5) + ((3*(3+1)+2) % 5)) - 100];
        C[3] = [A + 8*(5*((3) % 5) + ((3*(3+1)+3) % 5)) - 100];
        C[4] = [A + 8*(5*((4) % 5) + ((3*(3+1)+4) % 5)) - 100];

    // Row 4
    //r = 4;

        C[0] ^= D[(3*4+0)%5];
    i = rhotates(0,3*4+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*4+1)%5];
    i = rhotates(1,3*4+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*4+2)%5];
    i = rhotates(2,3*4+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*4+3)%5];
    i = rhotates(3,3*4+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*4+4)%5];
    i = rhotates(4,3*4+4);
    C[4] = ROL64(C[4], i);


        T0 = !(C[(0+1)%5]) & ( C[(0+2)%5]);
    T0 ^= C[0];
    [R + 8*(5*((4) % 5) + ((0) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(1+1)%5]) & ( C[(1+2)%5]);
    T0 ^= C[1];
    [R + 8*(5*((4) % 5) + ((1) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(2+1)%5]) & ( C[(2+2)%5]);
    T0 ^= C[2];
    [R + 8*(5*((4) % 5) + ((2) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(3+1)%5]) & ( C[(3+2)%5]);
    T0 ^= C[3];
    [R + 8*(5*((4) % 5) + ((3) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = !(C[(4+1)%5]) & ( C[(4+2)%5]);
    T0 ^= C[4];
    [R + 8*(5*((4) % 5) + ((4) % 5)) - 100] = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

    A, R = swap(A, R);

    C[0] = [A + 8*(5*((4) % 5) + ((0) % 5)) - 100];
    C[1] = [A + 8*(5*((4) % 5) + ((1) % 5)) - 100];
    C[2] = [A + 8*(5*((4) % 5) + ((2) % 5)) - 100];
    C[3] = [A + 8*(5*((4) % 5) + ((3) % 5)) - 100];
    C[4] = [A + 8*(5*((4) % 5) + ((4) % 5)) - 100];

    _, _, _, _, zf = #x86_TEST_8(iotas,255);
  } (!zf)

  iotas -= 192;
  A-=100;

  return A, iotas;
}



fn keccak_1600_add_full_block(
  reg u64 state,
  reg u64 in,
  reg u64 inlen,
  inline int rate_in_bytes
) -> reg u64, reg u64, reg u64
{
  inline int idx i;
  reg u64 t;

  for i = 0 to (rate_in_bytes / 8) 
  {
    t = [in + 8*i];
    [state + 8*(i)] ^= t;
  }

  in += rate_in_bytes;
  inlen -= rate_in_bytes;

  return state, in, inlen;
}



// obs: @pre: inlen < rate_in_bytes
fn keccak_1600_add_final_block(
  reg u64 state,
  reg u64 in,
  reg u64 inlen,
  inline int suffix,
  inline int rate_in_bytes
) -> reg u64
{
  reg u64 i t inlen8;
  reg u8 c;

  inlen8 = inlen;
  inlen8 >>= 3;
  i = 0;
  while ( i < inlen8 )
  {
    t = [in + 8*i];
    [state + 8*(i)] ^= t;
    i += 1;
  }
  i <<= 3;

  // inlen4 ?

  while ( i < inlen )
  {
    c = (u8)[in + i];
    (u8)[state + (i)] ^= c;
    i += 1;
  }

  (u8)[state + (i)] ^= suffix;
  (u8)[state + (rate_in_bytes-1)] ^= 0x80;

  return state;
}



fn keccak_1600_absorb(
  reg u64 state,
  reg u64 iotas,
  reg u64 in inlen,
  inline int suffix,
  inline int rate_in_bytes
) -> reg u64, reg u64
{
  stack u64 s_in s_inlen;

  // intermediate blocks
  while ( inlen >= rate_in_bytes )
  {
    state, in, inlen = keccak_1600_add_full_block(state, in, inlen, rate_in_bytes);
    s_in, s_inlen = spill_2(in, inlen);

    state, iotas = keccak_f(state, iotas);
    in, inlen = load_2(s_in, s_inlen);
  }

  // final block
  state = keccak_1600_add_final_block(state, in, inlen, suffix, rate_in_bytes);
  state, iotas = keccak_f(state, iotas);

  return state, iotas;
}



// obs: @pre: len <= rate_in_bytes
fn keccak_1600_xtr_block(
  reg u64 state,
  reg u64 out,
  reg u64 len
) -> reg u64
{
  reg u64 i t len8;
  reg u8 c;

  len8 = len;
  len8 >>= 3;
  i = 0;
  while ( i < len8 )
  {
    t = [state + 8*(i)];
    [out + 8*i] = t;
    i += 1;
  }
  i <<= 3;

  // inlen4 ?

  while ( i < len )
  {
    c = (u8)[state + (i)];
    (u8)[out + i] = c;
    i += 1;
  }

  out += len;
  return out;
}



fn keccak_1600_squeeze(
  reg u64 state,
  reg u64 iotas,
  reg u64 out,
  inline int rate_in_bytes,
  inline int i_hash_bytes
)
{
  stack u64 s_out s_hash_bytes;
  reg u64 hash_bytes;

  s_hash_bytes = i_hash_bytes;

  // intermediate blocks
  while ( s_hash_bytes >= rate_in_bytes )
  {    
    out = keccak_1600_xtr_block(state, out, rate_in_bytes);
    s_out = out;

    state, iotas = keccak_f(state, iotas);

    s_hash_bytes -= rate_in_bytes;
    out = s_out;
  }

  // final block
  hash_bytes = s_hash_bytes;
  out = keccak_1600_xtr_block(state, out, hash_bytes);
}



fn keccak_1600(
  reg u64 out, // output pointer with at least hash_bytes available
  reg u64 in, // input pointer with inlen bytes
  reg u64 inlen, // input length in bytes
  reg u64 iotas, // contains iotas, aligned at 256
  reg u64 m, // external memory for 2 states
  inline int suffix,
  inline int rate,
  inline int capacity,
  inline int hash_bytes
)
{
  stack u64 out_s;
  reg u64 state;

  out_s = out;
  state = keccak_init(m);

  // absorb
  state, iotas = keccak_1600_absorb(state, iotas, in, inlen, suffix, (rate/8));

  // squeeze
  out = out_s;
  keccak_1600_squeeze(state, iotas, out, (rate/8), hash_bytes);
}

export fn shake256_ref2x_jazz(reg u64 out in inlen iotas m)
{
  keccak_1600(out, in, inlen, iotas, m, 0x1F, 1088, 512, 136);
}
