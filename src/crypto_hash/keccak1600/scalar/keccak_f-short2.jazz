fn rename1(reg u64 x0 x1 x2 x3 x4
                   y0 y1 y2 y3 y4
) -> reg u64[5], reg u64[5]
{
  reg u64[5] X Y;
 
  X[0] = x0;
  X[1] = x1;
  X[2] = x2;
  X[3] = x3;
  X[4] = x4;
  Y[0] = y0;
  Y[1] = y1;
  Y[2] = y2;
  Y[3] = y3;
  Y[4] = y4;

  return X, Y;
}



fn keccak_f(
  _state_t A,
  reg u64 iotas
) -> _state_t, reg u64
{
  // https://github.com/openssl/openssl/blob/master/crypto/sha/keccak1600.c
  inline int i;
  reg bool zf;
  reg u64[5] C D;
  reg u64 T0 T1;
  _state_t R;

  setup(A,R)

  C[0] = S(A,4,0);
  C[1] = S(A,4,1);
  C[2] = S(A,4,2);
  C[3] = S(A,4,3);
  C[4] = S(A,4,4);

  // round loop
  align while {
    // obs: C[j] == S(A,4,j)
    D[0] = S(A,0,0);
    D[1] = S(A,1,1);
    D[2] = S(A,2,2);
    D[3] = S(A,3,3);

    C[2] ^= S(A,0,2);    // C[2] = A[0,4][2]
    C[3] ^= S(A,0,3);    // C[3] = A[0,4][3]
    C[0] ^= D[0];        // C[0] = A[0,4][0]
    C[1] ^= S(A,0,1);    // C[1] = A[0,4][1]
    C[2] ^= S(A,1,2);    // C[2] = A[0..1,4][2]
    C[0] ^= S(A,1,0);    // C[0] = A[0..1,4][0]

    D[4] = C[4];

    C[4] ^= S(A,0,4);    // C[4] = A[0,4][4]
    C[2] ^= D[2];        // C[2] = A[0..2,4][2]
    C[0] ^= S(A,2,0);    // C[0] = A[0..2,4][0]
    C[3] ^= S(A,1,3);    // C[3] = A[0,3..4][3]
    C[1] ^= D[1];        // C[1] = A[0..1,4][1]
    C[4] ^= S(A,1,4);    // C[4] = A[0..1,4][4]
    C[2] ^= S(A,3,2);    // C[2] = A[0..4][2] *
    C[0] ^= S(A,3,0);    // C[0] = A[0..4][0] *
    C[3] ^= S(A,2,3);    // C[3] = A[0,2..4][3]
    C[1] ^= S(A,2,1);    // C[1] = A[0..2,4][1]
    C[4] ^= S(A,2,4);    // C[4] = A[0..2,4][4]

    T0 = C[2];
    C[2] = ROL64(C[2], 1);
    C[2] ^= C[0];        // C[2] = ROL64(C[2], 1) ^ C[0]  // (D[1])
    C[3] ^= D[3];       // C[3] = A[0..4][3] *
    C[0] = ROL64(C[0], 1);
    C[0] ^= C[3];        // C[0] = ROL64(C[0], 1) ^ C[3]  // (D[4])
    C[1] ^= S(A,3,1);    // C[1] = A[0..4][4] *
    C[3] = ROL64(C[3], 1);
    C[3] ^= C[1];        // C[3] = ROL64(C[3], 1) ^ C[1]  // (D[2])
    C[4] ^= S(A,3,4);    // C[4] = A[0..4][4] *
    C[1] = ROL64(C[1], 1);
    C[1] ^= C[4];        // C[1] = ROL64(C[1], 1) ^ C[4]  // (D[0])
    C[4] = ROL64(C[4], 1);
    C[4] ^= T0;       // C[4] = ROL64(C[4], 1) ^ (C[2])  // (D[3])

    C, D = rename1(D[0],D[1],D[2],D[3],D[4],C[1],C[2],C[3],C[4],C[0]);

    // Row 0
    //r = 0;
        C[0] ^= D[(3*0+0)%5];
    i = rhotates(0,3*0+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*0+1)%5];
    i = rhotates(1,3*0+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*0+2)%5];
    i = rhotates(2,3*0+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*0+3)%5];
    i = rhotates(3,3*0+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*0+4)%5];
    i = rhotates(4,3*0+4);
    C[4] = ROL64(C[4], i);

        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
        T1 = ANDN(C[(1+1)%5], C[(1+2)%5]); //%%//
    T0 ^= C[0];
    T1 ^= C[1]; //%%//
        T0 ^= [iotas+0];
    iotas += 8;
    S(R,0,0) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]
    S(R,0,1) = T1; //%%//

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
    T0 ^= C[2];
    S(R,0,2) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
    T0 ^= C[3];
    S(R,0,3) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
    T0 ^= C[4];
    S(R,0,4) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        C[0] = S(A,0,3*(0+1)+0);
        C[1] = S(A,1,3*(0+1)+1);
        C[2] = S(A,2,3*(0+1)+2);
        C[3] = S(A,3,3*(0+1)+3);
        C[4] = S(A,4,3*(0+1)+4);

    // Row 1
    //r = 1;

        C[0] ^= D[(3*1+0)%5];
    i = rhotates(0,3*1+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*1+1)%5];
    i = rhotates(1,3*1+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*1+2)%5];
    i = rhotates(2,3*1+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*1+3)%5];
    i = rhotates(3,3*1+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*1+4)%5];
    i = rhotates(4,3*1+4);
    C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
    T0 ^= C[0];
    S(R,1,0) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
    T0 ^= C[1];
    S(R,1,1) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
    T0 ^= C[2];
    S(R,1,2) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
    T0 ^= C[3];
    S(R,1,3) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
    T0 ^= C[4];
    S(R,1,4) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = S(A,0,3*(1+1)+0);
        C[1] = S(A,1,3*(1+1)+1);
        C[2] = S(A,2,3*(1+1)+2);
        C[3] = S(A,3,3*(1+1)+3);
        C[4] = S(A,4,3*(1+1)+4);


    // Row 2
    //r = 2;

        C[0] ^= D[(3*2+0)%5];
    i = rhotates(0,3*2+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*2+1)%5];
    i = rhotates(1,3*2+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*2+2)%5];
    i = rhotates(2,3*2+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*2+3)%5];
    i = rhotates(3,3*2+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*2+4)%5];
    i = rhotates(4,3*2+4);
    C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
    T0 ^= C[0];
    S(R,2,0) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
    T0 ^= C[1];
    S(R,2,1) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
    T0 ^= C[2];
    S(R,2,2) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
    T0 ^= C[3];
    S(R,2,3) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
    T0 ^= C[4];
    S(R,2,4) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = S(A,0,3*(2+1)+0);
        C[1] = S(A,1,3*(2+1)+1);
        C[2] = S(A,2,3*(2+1)+2);
        C[3] = S(A,3,3*(2+1)+3);
        C[4] = S(A,4,3*(2+1)+4);

    // Row 3
    //r = 3;

        C[0] ^= D[(3*3+0)%5];
    i = rhotates(0,3*3+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*3+1)%5];
    i = rhotates(1,3*3+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*3+2)%5];
    i = rhotates(2,3*3+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*3+3)%5];
    i = rhotates(3,3*3+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*3+4)%5];
    i = rhotates(4,3*3+4);
    C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
    T0 ^= C[0];
    S(R,3,0) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
    T0 ^= C[1];
    S(R,3,1) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
    T0 ^= C[2];
    S(R,3,2) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
    T0 ^= C[3];
    S(R,3,3) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
    T0 ^= C[4];
    S(R,3,4) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]


        C[0] = S(A,0,3*(3+1)+0);
        C[1] = S(A,1,3*(3+1)+1);
        C[2] = S(A,2,3*(3+1)+2);
        C[3] = S(A,3,3*(3+1)+3);
        C[4] = S(A,4,3*(3+1)+4);

    // Row 4
    //r = 4;

        C[0] ^= D[(3*4+0)%5];
    i = rhotates(0,3*4+0);
    C[0] = ROL64(C[0], i);

        C[1] ^= D[(3*4+1)%5];
    i = rhotates(1,3*4+1);
    C[1] = ROL64(C[1], i);

        C[2] ^= D[(3*4+2)%5];
    i = rhotates(2,3*4+2);
    C[2] = ROL64(C[2], i);

        C[3] ^= D[(3*4+3)%5];
    i = rhotates(3,3*4+3);
    C[3] = ROL64(C[3], i);

        C[4] ^= D[(3*4+4)%5];
    i = rhotates(4,3*4+4);
    C[4] = ROL64(C[4], i);


        T0 = ANDN(C[(0+1)%5], C[(0+2)%5]);
    T0 ^= C[0];
    S(R,4,0) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(1+1)%5], C[(1+2)%5]);
    T0 ^= C[1];
    S(R,4,1) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(2+1)%5], C[(2+2)%5]);
    T0 ^= C[2];
    S(R,4,2) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(3+1)%5], C[(3+2)%5]);
    T0 ^= C[3];
    S(R,4,3) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

        T0 = ANDN(C[(4+1)%5], C[(4+2)%5]);
    T0 ^= C[4];
    S(R,4,4) = T0;    //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]

    A, R = swap(A, R);

    C[0] = S(A,4,0);
    C[1] = S(A,4,1);
    C[2] = S(A,4,2);
    C[3] = S(A,4,3);
    C[4] = S(A,4,4);

    _, _, _, _, zf = #x86_TEST_8(iotas,255);
  } (!zf)

  iotas -= 192;
  restore(A,R)

  return A, iotas;
}
