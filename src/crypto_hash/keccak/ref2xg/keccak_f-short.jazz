fn rename1(reg u64 x0 x1 x2 x3 x4
                   y0 y1 y2 y3 y4
) -> reg u64[5], reg u64[5]
{
  reg u64[5] X Y;
 
  X[0] = x0;
  X[1] = x1;
  X[2] = x2;
  X[3] = x3;
  X[4] = x4;
  Y[0] = y0;
  Y[1] = y1;
  Y[2] = y2;
  Y[3] = y3;
  Y[4] = y4;

  return X, Y;
}



fn keccak_f(
  _state_t A,
  reg u64 iotas
) -> _state_t, reg u64
{
  // https://github.com/openssl/openssl/blob/master/crypto/sha/keccak1600.c
  inline int r j i;
  reg bool zf;
  reg u64[5] C D;
  reg u64 T0;
  _state_t R;

  setup(A,R)

  C[0] = S(A,4,0);
  C[1] = S(A,4,1);
  C[2] = S(A,4,2);
  C[3] = S(A,4,3);
  C[4] = S(A,4,4);

  // round loop
  align while {
    // obs: C[j] == S(A,4,j)
    D[0] = S(A,0,0);
    D[1] = S(A,1,1);
    D[2] = S(A,2,2);
    D[3] = S(A,3,3);

    C[2] ^= S(A,0,2);  // C[2] = A[0,4][2]
    C[3] ^= S(A,0,3);  // C[3] = A[0,4][3]
    C[0] ^= D[0];      // C[0] = A[0,4][0]
    C[1] ^= S(A,0,1);  // C[1] = A[0,4][1]
    C[2] ^= S(A,1,2);  // C[2] = A[0..1,4][2]
    C[0] ^= S(A,1,0);  // C[0] = A[0..1,4][0]

    D[4] = C[4];

    C[4] ^= S(A,0,4);  // C[4] = A[0,4][4]
    C[2] ^= D[2];      // C[2] = A[0..2,4][2]
    C[0] ^= S(A,2,0);  // C[0] = A[0..2,4][0]
    C[3] ^= S(A,1,3);  // C[3] = A[0,3..4][3]
    C[1] ^= D[1];      // C[1] = A[0..1,4][1]
    C[4] ^= S(A,1,4);  // C[4] = A[0..1,4][4]
    C[2] ^= S(A,3,2);  // C[2] = A[0..4][2] *
    C[0] ^= S(A,3,0);  // C[0] = A[0..4][0] *
    C[3] ^= S(A,2,3);  // C[3] = A[0,2..4][3]
    C[1] ^= S(A,2,1);  // C[1] = A[0..2,4][1]
    C[4] ^= S(A,2,4);  // C[4] = A[0..2,4][4]

    T0 = C[2];
    C[2] = ROL64(C[2], 1);
    C[2] ^= C[0];      // C[2] = ROL64(C[2], 1) ^ C[0]  // (D[1])
    C[3] ^= D[3];      // C[3] = A[0..4][3] *
    C[0] = ROL64(C[0], 1);
    C[0] ^= C[3];      // C[0] = ROL64(C[0], 1) ^ C[3]  // (D[4])
    C[1] ^= S(A,3,1);  // C[1] = A[0..4][4] *
    C[3] = ROL64(C[3], 1);
    C[3] ^= C[1];      // C[3] = ROL64(C[3], 1) ^ C[1]  // (D[2])
    C[4] ^= S(A,3,4);  // C[4] = A[0..4][4] *
    C[1] = ROL64(C[1], 1);
    C[1] ^= C[4];      // C[1] = ROL64(C[1], 1) ^ C[4]  // (D[0])
    C[4] = ROL64(C[4], 1);
    C[4] ^= T0;        // C[4] = ROL64(C[4], 1) ^ (C[2])  // (D[3])

    C, D = rename1(D[0],D[1],D[2],D[3],D[4],C[1],C[2],C[3],C[4],C[0]);

    for r = 0 to 5
    { // obs: C[j] == S(A,j,3*r+j)
      for j = 0 to 5
      { C[j] ^= D[(3*r+j)%5];
        i = rhotates(j,3*r+j);
        C[j] = ROL64(C[j], i);
      }

      for j = 0 to 5
      { T0 = ANDN(C[(j+1)%5], C[(j+2)%5]);
        T0 ^= C[j];
        if (r==0 && j==0)
        { T0 ^= [iotas+0];
          iotas += 8;
        }
        S(R,r,j) = T0;  //C[j] ^ (~C[(j+1)%5] & C[(j+2)%5]) [^[iotas]]
      }
      if (r<4)
      { for j = 0 to 5
        { C[j] = S(A,j,3*(r+1)+j);
        }
      } else
      { for j = 0 to 5
        { C[j] = S(R,4,j);
        }
      }
    }

    A, R = swap(A, R);
    _, _, _, _, zf = #x86_TEST_8(iotas,255);
  } (!zf)

  iotas -= 192;

  restore(A,R)

  return A, iotas;
}
