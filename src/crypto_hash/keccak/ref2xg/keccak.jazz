// TODO refactor iotas when global arrays are supported

#ifndef KECCAK_F_IMPL
  // 0 includes "keccak_f.jazz"
  // 1 includes "keccak_f-short.jazz"
  // 2 includes "keccak_f-short2.jazz"
  // 3 includes "keccak_f-openssl.jazz"
  #define KECCAK_F_IMPL 0
#endif

#ifndef STATE_IN_STACK
  // 0 uses external memory for the stack space
  // 1 uses stack u64[] array
  #define STATE_IN_STACK 1
#endif

#if !STATE_IN_STACK
  #define _state_t reg u64
  #define OFFSET 100
  #define S(base,x,y) [base + 8*(5*((x) % 5) + ((y) % 5)) - OFFSET]
  #define B(base,x) [base + 8*(x)]
  #define B8(base,x) (u8)[base + (x)]

  fn swap(_state_t a b) -> _state_t, _state_t
  { _state_t t;
    t = a; a = b; b = t; // XCHG
    return a, b; }

  #define setup(a,b) a += OFFSET;b = a + 200;
  #define restore(a,b) a-=OFFSET;

#else
  #define _state_t stack u64[25]
  #define S(base,x,y) base[(5*((x) % 5) + ((y) % 5))]
  #define B(base,x) base[(int)x]
  #define B8(base,x) base[u8 (int)(x)]

  // TODO: README
  // atm I think this is the best way of simulating this particular stack swap
  // we only need the contents of b to be put in a
  // if we could swap directly the stack pointers would be cool :-)
  // in the case that is unfeasible we could try to unroll the main loop 2x
  fn swap(_state_t a b) -> _state_t, _state_t
  { inline int i; reg u64 t;
    for i=0 to 25
    { t=b[i]; a[i]=t; }
    return a, b;}

  #define setup(a,b)
  #define restore(a,b)

#endif


fn spill_2(reg u64 a b) -> stack u64, stack u64
{
  stack u64 sa sb;
  sa = a;
  sb = b;
  return sa, sb;
}



fn load_2(stack u64 sa sb) -> reg u64, reg u64
{
  reg u64 a b;
  a = sa;
  b = sb;
  return a, b;
}



#define ANDN(x,y) !(x) & (y)



fn ROL64(reg u64 x, inline int c) -> reg u64
{
  reg u64 y;
  if (c == 0)
  { y = x; }
  else
  { _, _, y = #x86_ROL_64(x, c); }
  return y;
}



fn keccak_init(
  #if !STATE_IN_STACK
  reg u64 m
  #endif
) -> _state_t
{
  _state_t state;
  reg u64 i t;

  _, _, _, _, _, t = #set0();

  #if !STATE_IN_STACK
  state = m; //if state is in stack this is just ignored
  #endif

  i = 0;
  while (i < 25)
  { B(state,i) = t;
    i += 1;
  }

  return state;
}



fn index(inline int x, inline int y) -> inline int {
  inline int r;
  r = 5*(x % 5) + (y % 5);
  return r;
}



fn keccak_rho_offsets(inline int i) -> inline int
{
  inline int r, x, y, z, t;
  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24
  { if i == x + 5 * y
    { r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}



fn rhotates(inline int x y) -> inline int
{
  inline int i r;
  i = index(x, y);
  r = keccak_rho_offsets(i);
  return r;
}



#if KECCAK_F_IMPL==0
#include "keccak_f.jazz"
#elif KECCAK_F_IMPL==1
#include "keccak_f-short.jazz"
#elif KECCAK_F_IMPL==2
#include "keccak_f-short2.jazz"
#else
#include "keccak_f-openssl.jazz"
#endif



fn keccak_1600_add_full_block(
  _state_t state,
  reg u64 in,
  reg u64 inlen,
  inline int rate_in_bytes
) -> _state_t, reg u64, reg u64
{
  inline int idx i;
  reg u64 t;

  for i = 0 to (rate_in_bytes / 8)
  {
    t = [in + 8*i];
    B(state,i) ^= t;
  }

  in += rate_in_bytes;
  inlen -= rate_in_bytes;

  return state, in, inlen;
}


#if 0
// obs: @pre: inlen < rate_in_bytes
fn keccak_1600_add_final_block(
  _state_t state,
  reg u64 in,
  reg u64 inlen,
  inline int suffix,
  inline int rate_in_bytes
) -> _state_t
{
  reg u64 i t inlen8;
  reg u8 c;

  inlen8 = inlen;
  inlen8 >>= 3;
  i = 0;
  while ( i < inlen8 )
  {
    t = [in + 8*i];
    B(state,i) ^= t;
    i += 1;
  }
  i <<= 3;

  // inlen4 ?

  while ( i < inlen )
  {
    c = (u8)[in + i];
    B8(state,i) ^= c;
    i += 1;
  }

  B8(state,i) ^= suffix;
  B8(state,rate_in_bytes-1) ^= 0x80;

  return state;
}
#else

// obs: @pre: inlen < 8
fn lastu64(
  reg u64 in inlen,
  inline int suffix
) -> reg u64
{
  reg bool zf;
  reg u64 res delta t suffix_u64;

  res = 0;
  delta = 0;
  zf = #x86_TEST_8(inlen,4);
  if (!zf) {
    res = (64u)(u32)[in + 0];
    in += 4;
    delta = 32;
  }
  zf = #x86_TEST_8(inlen,2);
  if (!zf) {
    t = (64u)(u16)[in + 0];
    in += 2;
    t <<= delta;
    delta += 16;
    res += t;
  }
  zf = #x86_TEST_8(inlen,1);
  if (!zf) {
    t = (64u)(u8)[in + 0];
    t <<= delta;
    delta += 8;
    res += t;
  }
  suffix_u64 = suffix;
  suffix_u64 <<= delta;
  res += suffix_u64;

  return res;
}


// obs: @pre: inlen < rate_in_bytes
fn keccak_1600_add_final_block(
  _state_t state,
  reg u64 in,
  reg u64 inlen,
  inline int suffix,
  inline int rate_in_bytes
) -> _state_t
{
  reg u64 i t inlen8;
  reg u8 c;

  inlen8 = inlen;
  inlen8 >>= 3;
  i = 0;
  while ( i < inlen8 )
  {
    t = [in + 8*i];
    B(state,i) ^= t;
    i += 1;
  }
  in += 8*i;
  inlen &= 7; // inlen = inlen % 8
  t = lastu64(in, inlen, suffix);
  B(state,i) ^= t;

  B8(state,rate_in_bytes-1) ^= 0x80;

  return state;
}
#endif



fn keccak_1600_absorb(
  _state_t state,
  reg u64 iotas,
  reg u64 in inlen,
  inline int suffix,
  inline int rate_in_bytes
) -> _state_t, reg u64
{
  stack u64 s_in s_inlen;

  // intermediate blocks
  while ( inlen >= rate_in_bytes )
  {
    state, in, inlen = keccak_1600_add_full_block(state, in, inlen, rate_in_bytes);
    s_in, s_inlen = spill_2(in, inlen);

    state, iotas = keccak_f(state, iotas);
    in, inlen = load_2(s_in, s_inlen);
  }

  // final block
  state = keccak_1600_add_final_block(state, in, inlen, suffix, rate_in_bytes);

  return state, iotas;
}



// obs: @pre: len <= rate_in_bytes
fn keccak_1600_xtr_block(
  _state_t state,
  reg u64 out,
  reg u64 len
) -> reg u64
{
  reg u64 i t len8;
  reg u8 c;

  len8 = len;
  len8 >>= 3;
  i = 0;
  while ( i < len8 )
  {
    t = B(state,i);
    [out + 8*i] = t;
    i += 1;
  }
  i <<= 3;

  // inlen4 ?

  while ( i < len )
  {
    c = B8(state,i);
    (u8)[out + i] = c;
    i += 1;
  }

  out += len;
  return out;
}



fn keccak_1600_squeeze(
  _state_t state,
  reg u64 iotas,
  reg u64 out,
  stack u64 s_hash_bytes,
  inline int rate_in_bytes
)
{
  stack u64 s_out;
  reg u64 hash_bytes;

  // intermediate blocks
  while ( s_hash_bytes >s 0 )
  {
    s_out = out;
    state, iotas = keccak_f(state, iotas);
    out = s_out;

    if( s_hash_bytes >= rate_in_bytes)
    {
      out = keccak_1600_xtr_block(state, out, rate_in_bytes);
      s_hash_bytes -= rate_in_bytes;
    }
    else
    {
      hash_bytes = s_hash_bytes;
      out = keccak_1600_xtr_block(state, out, hash_bytes);
      s_hash_bytes = 0;
    }
  }
}



fn keccak_1600(
  reg u64 out, // output pointer with at least hash_bytes available
  reg u64 in, // input pointer with inlen bytes
  reg u64 inlen, // input length in bytes
  reg u64 iotas_, // contains iotas, aligned at 256
  #if !STATE_IN_STACK
  reg u64 m, // external memory for 2 states
  #endif
  reg u64 hash_bytes,
  inline int suffix,
  inline int rate,
  inline int capacity
)
{
  stack u64 out_s s_hash_bytes;
  _state_t state;
  reg u64 iotas; // lastu64 needs iota register

  iotas = iotas_;

  out_s = out;
  s_hash_bytes = hash_bytes;

  state = keccak_init(
    #if !STATE_IN_STACK
    m
    #endif
  );

  // absorb
  state, iotas = keccak_1600_absorb(state, iotas, in, inlen, suffix, (rate/8));

  // squeeze
  out = out_s;
  keccak_1600_squeeze(state, iotas, out, s_hash_bytes, (rate/8));
}
