fn theta_sum(_state_t A) -> reg u64[5]
{
  inline int idx i j;
  reg u64[5] C;
  reg u64 t;

  for i = 0 to 5
  { C[i] = S(A, 0, i);
    for j = 1 to 5
    { C[i] ^= S(A, j, i);
    }
  }

  return C;
}



fn theta_rol(reg u64[5] C) -> reg u64[5]
{
  inline int i;
  reg u64[5] D;
  reg u64 t r;

  for i = 0 to 5
  {
    r = ROL64(C[(i+1)%5], 1);
    D[i] = r;
    D[i] ^= C[(i+4)%5];
  }

  return D;
}



fn rol_sum(
  reg u64[5] D,
  _state_t A,
  inline int offset
) -> reg u64[5]
{
  inline int idx j j1 k;
  reg u64[5] C;
  reg u64 t;

  for j = 0 to 5
  {
    j1 = (j+offset) % 5;
    k = rhotates(j, j1);
    t = S(A,j,j1);
    t ^= D[j1];
    t = ROL64(t, k);
    C[j] = t;
  }

  return C;
}



fn set_row(
  _state_t R,
  inline int row,
  reg u64[5] C,
  stack u64 iota
) -> _state_t
{
  inline int idx j j1 j2;
  reg u64 t;

  for j= 0 to 5
  {
    j1 = (j+1) % 5;
    j2 = (j+2) % 5;
    t = ANDN( C[j1], C[j2] );
    if row==0 && j==0 { t ^= iota; }
    t ^= C[j];
    S(R, row, j) = t;
  }

  return R;
}



fn round2x(
  _state_t A,
  _state_t R,
  reg u64 iotas,
  inline int o
) -> _state_t, _state_t
{
  reg u64[5] C D;
  stack u64 iota;

  iota = [iotas + o];
  C = theta_sum(A);
  D = theta_rol(C);
  C = rol_sum(D, A, 0);
  R = set_row(R, 0, C, iota);
  C = rol_sum(D, A, 3);
  R = set_row(R, 1, C, iota);
  C = rol_sum(D, A, 1);
  R = set_row(R, 2, C, iota);
  C = rol_sum(D, A, 4);
  R = set_row(R, 3, C, iota);
  C = rol_sum(D, A, 2);
  R = set_row(R, 4, C, iota);

  return A, R;
}



fn keccak_f(
  _state_t A,
  reg u64 iotas
) -> _state_t, reg u64
{
  reg bool zf;
  _state_t R;

  setup(A,R)

  while
  {
    A, R = round2x(A, R, iotas, 0);
    R, A = round2x(R, A, iotas, 8);
    iotas += 16;
    _, _, _, _, zf = #x86_TEST_8(iotas,255);
  } (!zf)

  iotas -= 192;

  restore(A,R)

  return A, iotas;
}
