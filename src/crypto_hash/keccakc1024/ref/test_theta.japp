fn theta(reg u64[25] state) -> reg u64[25]
{
  inline int x y;
  reg u64[5] bc;
  reg u64 r temp;

  for x=0 to 5
  {
    bc[x]  = state[x];
    bc[x] ^= state[5 + x];
    bc[x] ^= state[10 + x];
    bc[x] ^= state[15 + x];
    bc[x] ^= state[20 + x];
  }

  for x=0 to 5
  {
    temp = bc[(x+4) % 5];
    _, _, r = #x86_ROL_64(bc[(x+1) % 5], 1);
    temp ^= r;
    for y=0 to 5
    {
      state[(y*5) + x] ^= temp;
    }
  }

  return state;
}


fn test_theta_from_register() -> reg u64[25]
{
  inline int i;
  reg u64[25] state;

  for i=0 to 25
  { state[i] = -1;
    state[i] <<= i;
  }

  state = theta(state);

  return state;
}

fn test_theta_from_memory() -> reg u64[25]
{
  inline int i;
  reg u64[25] state;
  reg u64 in;

  in = 0x0;

  (u128)[in + 0]    = (16u8)[0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c];
  (u128)[in + 16]   = (16u8)[0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73];
  (u128)[in + 32]   = (16u8)[0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63];
  (u128)[in + 48]   = (16u8)[0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f];
  (u128)[in + 64]   = (16u8)[0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20];
  (u128)[in + 80]   = (16u8)[0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73];
  (u128)[in + 96]   = (16u8)[0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69];
  (u128)[in + 112]  = (16u8)[0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c];
  (u128)[in + 128]  = (16u8)[0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73];
  (u128)[in + 144]  = (16u8)[0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63];
  (u128)[in + 160]  = (16u8)[0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f];
  (u128)[in + 176]  = (16u8)[0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20];
  (u128)[in + 192]  = (16u8)[0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73];

  for i=0 to 25
  { state[i] = [in + 8*i]; }

  state = theta(state);

  return state;
}

exec test_theta_from_register()

exec test_theta_from_memory
(
  0x0:208
)




inline
fn pow2m1(inline int n) -> inline int {
  inline int i, r;
  r = 1;
  for i = 0 to n { r *= 2; }
  r -= 1;
  return r;
}



fn keccakRoundConstants() -> stack u64[24] {
  stack u64[24] constants;
  inline u8 lfsr, lsb;
  inline u64 c;
  reg u64 r;
  inline int i, j, bp;

  lfsr = 1;
  for i = 0 to 24 {
    c = 0;
    for j = 0 to 7 {
      bp = pow2m1(j);
      lsb = lfsr & 0x1;
      if (lfsr & 0x80) != 0 {
        lfsr = (lfsr << 1) ^ 0x71;
      } else {
        lfsr <<= 1;
      }
      if lsb != 0 { c ^= 1 << bp; }
    }
    if c >= 2147483648 {
      r = c;
      constants[i] = r;
    } else {
      constants[i] = c;
    }
  }
  return constants;
}

exec keccakRoundConstants()
