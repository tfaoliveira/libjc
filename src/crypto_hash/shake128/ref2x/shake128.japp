// TODO refactor iotas when global arrays are supported



        
  // TODO: README
  // atm I think this is the best way of simulating this particular stack swap
  // we only need the contents of b to be put in a
  // if we could swap directly the stack pointers would be cool :-)
  // in the case that is unfeasible we could try to unroll the main loop 2x
  fn swap(stack u64[25] a b) -> stack u64[25], stack u64[25]
  { inline int i; reg u64 t;
    for i=0 to 25
    { t=b[i]; a[i]=t; }    
    return a, b;}

    


fn spill_2(reg u64 a b) -> stack u64, stack u64
{
  stack u64 sa sb;
  sa = a;
  sb = b;
  return sa, sb;
}



fn load_2(stack u64 sa sb) -> reg u64, reg u64
{
  reg u64 a b;
  a = sa;
  b = sb;
  return a, b;
}






fn ROL64(reg u64 x, inline int c) -> reg u64
{
  reg u64 y;
  if (c == 0)
  { y = x; }
  else
  { _, _, y = #x86_ROL_64(x, c); }
  return y;
}



fn keccak_init(reg u64 m) -> stack u64[25]
{
  stack u64[25] state;
  reg u64 i t;

  _, _, _, _, _, t = #set0();

  
  i = 0;
  while (i < 50)
  { state[(int)i] = t;
    i += 1;
  }

  return state;
}



fn index(inline int x, inline int y) -> inline int {
  inline int r;
  r = 5*(x % 5) + (y % 5);
  return r;
}



fn keccak_rho_offsets(inline int i) -> inline int
{
  inline int r, x, y, z, t;
  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24
  { if i == x + 5 * y
    { r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}



fn rhotates(inline int x y) -> inline int
{
  inline int i r;
  i = index(x, y);
  r = keccak_rho_offsets(i);
  return r;
}



fn theta_sum(stack u64[25] A) -> reg u64[5]
{
  inline int idx i j;
  reg u64[5] C;
  reg u64 t;

  for i = 0 to 5
  { C[i] = A[(5*(( 0) % 5) + (( i) % 5))];
    for j = 1 to 5
    { C[i] ^= A[(5*(( j) % 5) + (( i) % 5))];
    }
  }

  return C;
}



fn theta_rol(reg u64[5] C) -> reg u64[5]
{
  inline int i;
  reg u64[5] D;
  reg u64 t r;

  for i = 0 to 5
  {
    r = ROL64(C[(i+1)%5], 1);
    D[i] = r;
    D[i] ^= C[(i+4)%5];
  }

  return D;
}



fn rol_sum(
  reg u64[5] D,
  stack u64[25] A,
  inline int offset
) -> reg u64[5]
{
  inline int idx j j1 k;
  reg u64[5] C;
  reg u64 t;

  for j = 0 to 5
  {
    j1 = (j+offset) % 5;
    k = rhotates(j, j1);
    t = A[(5*((j) % 5) + ((j1) % 5))];
    t ^= D[j1];
    t = ROL64(t, k);
    C[j] = t;
  }

  return C;
}



fn set_row(
  stack u64[25] R,
  inline int row,
  reg u64[5] C,
  stack u64 iota
) -> stack u64[25]
{
  inline int idx j j1 j2;
  reg u64 t;

  for j= 0 to 5
  {
    j1 = (j+1) % 5;
    j2 = (j+2) % 5;
    t = !( C[j1]) & ( C[j2] );
    if row==0 && j==0 { t ^= iota; }
    t ^= C[j];
    R[(5*(( row) % 5) + (( j) % 5))] = t;
  }

  return R;
}



fn round2x(
  stack u64[25] A,
  stack u64[25] R,
  reg u64 iotas,
  inline int o
) -> stack u64[25], stack u64[25]
{
  reg u64[5] C D;
  stack u64 iota;

  iota = [iotas + o];
  C = theta_sum(A);
  D = theta_rol(C);
  C = rol_sum(D, A, 0);
  R = set_row(R, 0, C, iota);
  C = rol_sum(D, A, 3);
  R = set_row(R, 1, C, iota);
  C = rol_sum(D, A, 1);
  R = set_row(R, 2, C, iota);
  C = rol_sum(D, A, 4);
  R = set_row(R, 3, C, iota);
  C = rol_sum(D, A, 2);
  R = set_row(R, 4, C, iota);

  return A, R;
}



fn keccak_f(
  stack u64[25] A,
  reg u64 iotas
) -> stack u64[25], reg u64
{
  reg bool zf;
  stack u64[25] R;

  

  align while
  {
    A, R = round2x(A, R, iotas, 0);
    R, A = round2x(R, A, iotas, 8);
    iotas += 16;
    _, _, _, _, zf = #x86_TEST_8(iotas,255);
  } (!zf)

  iotas -= 192;

  

  return A, iotas;
}



fn keccak_1600_add_full_block(
  stack u64[25] state,
  reg u64 in,
  reg u64 inlen,
  inline int rate_in_bytes
) -> stack u64[25], reg u64, reg u64
{
  inline int idx i;
  reg u64 t;

  for i = 0 to (rate_in_bytes / 8) 
  {
    t = [in + 8*i];
    state[(int)i] ^= t;
  }

  in += rate_in_bytes;
  inlen -= rate_in_bytes;

  return state, in, inlen;
}



// obs: @pre: inlen < rate_in_bytes
fn keccak_1600_add_final_block(
  stack u64[25] state,
  reg u64 in,
  reg u64 inlen,
  inline int suffix,
  inline int rate_in_bytes
) -> stack u64[25]
{
  reg u64 i t inlen8;
  reg u8 c;

  inlen8 = inlen;
  inlen8 >>= 3;
  i = 0;
  while ( i < inlen8 )
  {
    t = [in + 8*i];
    state[(int)i] ^= t;
    i += 1;
  }
  i <<= 3;

  // inlen4 ?

  while ( i < inlen )
  {
    c = (u8)[in + i];
    state[u8 (int)(i)] ^= c;
    i += 1;
  }

  state[u8 (int)(i)] ^= suffix;
  state[u8 (int)(rate_in_bytes-1)] ^= 0x80;

  return state;
}



fn keccak_1600_absorb(
  stack u64[25] state,
  reg u64 iotas,
  reg u64 in inlen,
  inline int suffix,
  inline int rate_in_bytes
) -> stack u64[25], reg u64
{
  stack u64 s_in s_inlen;

  // intermediate blocks
  while ( inlen >= rate_in_bytes )
  {
    state, in, inlen = keccak_1600_add_full_block(state, in, inlen, rate_in_bytes);
    s_in, s_inlen = spill_2(in, inlen);

    state, iotas = keccak_f(state, iotas);
    in, inlen = load_2(s_in, s_inlen);
  }

  // final block
  state = keccak_1600_add_final_block(state, in, inlen, suffix, rate_in_bytes);
  state, iotas = keccak_f(state, iotas);

  return state, iotas;
}



// obs: @pre: len <= rate_in_bytes
fn keccak_1600_xtr_block(
  stack u64[25] state,
  reg u64 out,
  reg u64 len
) -> reg u64
{
  reg u64 i t len8;
  reg u8 c;

  len8 = len;
  len8 >>= 3;
  i = 0;
  while ( i < len8 )
  {
    t = state[(int)i];
    [out + 8*i] = t;
    i += 1;
  }
  i <<= 3;

  // inlen4 ?

  while ( i < len )
  {
    c = state[u8 (int)(i)];
    (u8)[out + i] = c;
    i += 1;
  }

  out += len;
  return out;
}



fn keccak_1600_squeeze(
  stack u64[25] state,
  reg u64 iotas,
  reg u64 out,
  inline int rate_in_bytes,
  inline int i_hash_bytes
)
{
  stack u64 s_out s_hash_bytes;
  reg u64 hash_bytes;

  s_hash_bytes = i_hash_bytes;

  // intermediate blocks
  while ( s_hash_bytes >= rate_in_bytes )
  {    
    out = keccak_1600_xtr_block(state, out, rate_in_bytes);
    s_out = out;

    state, iotas = keccak_f(state, iotas);

    s_hash_bytes -= rate_in_bytes;
    out = s_out;
  }

  // final block
  hash_bytes = s_hash_bytes;
  out = keccak_1600_xtr_block(state, out, hash_bytes);
}



fn keccak_1600(
  reg u64 out, // output pointer with at least hash_bytes available
  reg u64 in, // input pointer with inlen bytes
  reg u64 inlen, // input length in bytes
  reg u64 iotas, // contains iotas, aligned at 256
  reg u64 m, // external memory for 2 states
  inline int suffix,
  inline int rate,
  inline int capacity,
  inline int hash_bytes
)
{
  stack u64 out_s;
  stack u64[25] state;

  out_s = out;
  state = keccak_init(m);

  // absorb
  state, iotas = keccak_1600_absorb(state, iotas, in, inlen, suffix, (rate/8));

  // squeeze
  out = out_s;
  keccak_1600_squeeze(state, iotas, out, (rate/8), hash_bytes);
}

export fn shake128_ref2x_jazz(reg u64 out in inlen iotas m)
{
  keccak_1600(out, in, inlen, iotas, m, 0x1F, 1344, 256, 168);
}
